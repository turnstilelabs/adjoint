'use client';

import { create } from 'zustand';
import { type Sublemma } from '@/ai/flows/llm-proof-decomposition';
import { type Message } from '@/components/chat/interactive-chat';
import { type GraphData } from '@/components/proof-graph';
import type { ExploreArtifacts } from '@/ai/exploration-assistant/exploration-assistant.schemas';
import {
  attemptProofAction,
  attemptProofActionForce,
  decomposeRawProofAction,
  generateProofGraphForGoalAction,
} from '@/app/actions';

export type View = 'home' | 'explore' | 'workspace' | 'proof';

// Extended ProofVersion to support raw vs structured versions, numbering and metadata
export type ProofVersion = {
  id: string;
  type: 'raw' | 'structured';
  versionNumber: string; // e.g. "1" or "2.1"
  baseMajor: number; // major raw version this structured version belongs to
  sublemmas: Sublemma[];
  // Optional raw/serialized content for this version
  content?: string;
  // Optional structured payload (lightweight summary)
  structured?: {
    provedStatement?: string;
    normalizedProof?: string;
  };
  // Flags
  userEdited?: boolean; // true when user explicitly edited this version
  derived?: boolean; // true when auto-generated by decomposition
  timestamp: Date;
  /** Whole-proof analysis result (existing footer). */
  validationResult?: ProofValidationResult;
  /** Per-step analysis results keyed by 0-based step index. */
  stepValidation?: Record<number, ProofValidationResult>;
  /** Which step was last edited (for contextual CTA). */
  lastEditedStepIdx?: number | null;
  graphData?: GraphData;
  /** Hash used to dedupe graph generation for identical structured step sets. */
  graphHash?: string;
};

export type PendingSuggestion = {
  suggested: string; // model-proposed final statement
  variantType: 'WEAKENING' | 'OPPOSITE';
  provedStatement: string; // extracted from raw proof decomposition
  sublemmas: Sublemma[]; // pre-decomposed steps for instant accept
  explanation: string;
  normalizedProof?: string; // full normalized proof text for fallback rendering
  rawProof?: string; // original raw proof text for fallback rendering
};
export type ProofValidationResult = {
  isError?: boolean;
  isValid?: boolean;
  feedback: string;
  timestamp: Date;
  model?: string;
  /** Used to prevent re-running analysis when the underlying proof input is unchanged. */
  sourceType?: 'raw' | 'structured';
  /** Hash of the proof input (raw text or structured steps) for de-duping. */
  sourceHash?: string;
};

// Lightweight UUID generator for client-side ids
const uuid = () => 'v' + Math.random().toString(36).slice(2, 9);

// Helpers to create version objects
const getMaxRawMajor = (history: ProofVersion[]) =>
  history.reduce((m, v) => (v.type === 'raw' ? Math.max(m, v.baseMajor) : m), 0);

const makeRawVersion = (history: ProofVersion[], content: string) => {
  const nextMajor = (getMaxRawMajor(history) || 0) + 1;
  return {
    id: uuid(),
    type: 'raw' as const,
    versionNumber: `${nextMajor}`,
    baseMajor: nextMajor,
    content,
    sublemmas: [] as Sublemma[],
    userEdited: true,
    derived: false,
    timestamp: new Date(),
    validationResult: undefined,
    stepValidation: undefined,
    lastEditedStepIdx: null,
    graphData: undefined,
    graphHash: undefined,
  } as ProofVersion;
};

const makeStructuredVersion = (
  history: ProofVersion[],
  baseMajor: number,
  steps: Sublemma[],
  structuredPayload: { provedStatement?: string; normalizedProof?: string },
  opts?: { userEdited?: boolean; derived?: boolean },
) => {
  const minors = history
    .filter((v) => v.baseMajor === baseMajor && v.type === 'structured')
    .map((v) => {
      const parts = (v.versionNumber || '').split('.');
      return parts.length > 1 ? parseInt(parts[1], 10) || 0 : 0;
    });
  const nextMinor = (minors.length ? Math.max(...minors) : 0) + 1;
  const versionNumber = `${baseMajor}.${nextMinor}`;
  return {
    id: uuid(),
    type: 'structured' as const,
    versionNumber,
    baseMajor,
    content: structuredPayload.normalizedProof || '',
    structured: structuredPayload,
    sublemmas: steps,
    userEdited: !!opts?.userEdited,
    derived: opts?.derived ?? true,
    timestamp: new Date(),
    validationResult: undefined,
    stepValidation: undefined,
    lastEditedStepIdx: null,
    graphData: undefined,
    graphHash: undefined,
  } as ProofVersion;
};

// Autosave debounce timer (module-level so multiple components share it)
let rawAutosaveTimer: number | null = null;
let lastSavedRaw = '';

type StoreData = {
  view: View;
  problem: string | null;
  lastProblem: string | null;
  messages: Message[];

  /** Draft text prefilled into the proof-mode chat input (used by global selection toolbar). */
  chatDraft: string;
  /** Bumped to request focus/apply of chatDraft. */
  chatDraftNonce: number;

  /** Draft text prefilled into the explore-mode chat input (used by global selection toolbar). */
  exploreDraft: string;
  /** Bumped to request focus/apply of exploreDraft. */
  exploreDraftNonce: number;

  // Explore mode
  exploreSeed: string | null;
  exploreMessages: Message[];
  exploreArtifacts: ExploreArtifacts | null;
  /**
   * User edits overlay for extracted artifacts.
   * Keyed by the original extracted string -> edited string.
   */
  exploreArtifactEdits: {
    candidateStatements: Record<string, string>;
    /**
     * Non-statement artifacts are scoped per candidate statement (keyed by the original statement string).
     */
    perStatement: Record<
      string,
      {
        assumptions: Record<string, string>;
        examples: Record<string, string>;
        counterexamples: Record<string, string>;
      }
    >;
  };
  exploreTurnId: number;
  cancelExploreCurrent?: (() => void) | null;

  loading: boolean;
  error: string | null;
  errorDetails: string | null;
  errorCode: string | null;
  isChatOpen: boolean;
  isHistoryOpen: boolean;
  viewMode: 'raw' | 'structured' | 'graph';
  proofHistory: ProofVersion[];

  // Raw proof + background decomposition state
  rawProof: string;
  /** Incremented to request that the Raw Proof editor enters editing mode + focuses. */
  rawProofEditNonce: number;
  attemptSummary: {
    status: 'PROVED_AS_IS' | 'PROVED_VARIANT' | 'FAILED';
    finalStatement: string | null;
    variantType: 'WEAKENING' | 'OPPOSITE' | null;
    explanation: string;
  } | null;
  isDecomposing: boolean;
  decomposeError: string | null;
  stepsReadyNonce: number;
  decomposeMeta: { provedStatement: string; normalizedProof: string } | null;
  /** The raw proof text that the latest decomposition corresponds to (used to know whether steps are up-to-date). */
  decomposedRaw: string | null;
  activeVersionIdx: number;
  pendingSuggestion: PendingSuggestion | null;
  pendingRejection: { explanation: string } | null;
  // Streaming progress
  progressLog: string[];
  // Cancel the current in-flight streaming request (if any)
  cancelCurrent?: (() => void) | null;
  // Live draft streaming (token-level)
  liveDraft: string;
  isDraftStreaming: boolean;

  // Whole-proof analysis UI state
  isAnalyzingProof: boolean;
  analyzeProofRunId: number;

  // Workspace (single-file editor + per-selection threads)
  workspaceDoc: string;
  workspaceMessages: Message[];
  /** Draft text prefilled into the workspace chat input (used by selection toolbar). */
  workspaceDraft: string;
  workspaceDraftNonce: number;
  isWorkspaceChatOpen: boolean;
  workspaceRightPanelTab: 'chat' | 'insights' | 'preview';
  workspaceRightPanelWidth: number; // px

  // Workspace Insights (Explore-style artifacts)
  workspaceArtifacts: ExploreArtifacts | null;
  workspaceArtifactEdits: {
    candidateStatements: Record<string, string>;
    perStatement: Record<
      string,
      {
        assumptions: Record<string, string>;
        examples: Record<string, string>;
        counterexamples: Record<string, string>;
      }
    >;
  };
  workspaceTurnId: number;
  cancelWorkspaceCurrent?: (() => void) | null;
};

interface AppState extends StoreData {
  reset: () => void;

  /** Navigate back to homepage without clearing current workspace/proof state. */
  goHome: () => void;

  /** Prefill + focus the proof-mode chat input (and optionally open the chat panel). */
  setChatDraft: (text: string, opts?: { open?: boolean }) => void;

  /** Prefill + focus the explore-mode chat input. */
  setExploreDraft: (text: string) => void;

  // Workspace actions
  startWorkspace: (seed?: string) => void;
  newWorkspace: () => void;
  setWorkspaceDoc: (doc: string) => void;
  setWorkspaceDraft: (text: string, opts?: { open?: boolean }) => void;
  setWorkspaceMessages: (updater: ((prev: Message[]) => Message[]) | Message[]) => void;
  setIsWorkspaceChatOpen: (open: boolean | ((prev: boolean) => boolean)) => void;
  setWorkspaceRightPanelTab: (tab: 'chat' | 'insights' | 'preview') => void;
  setWorkspaceRightPanelWidth: (widthPx: number) => void;

  // Workspace Insights actions
  setWorkspaceArtifacts: (artifacts: ExploreArtifacts | null) => void;
  setWorkspaceArtifactEdit: (opts: {
    kind: 'candidateStatements' | 'assumptions' | 'examples' | 'counterexamples';
    statementKey?: string;
    original: string;
    edited: string;
  }) => void;
  bumpWorkspaceTurnId: () => number;
  getWorkspaceTurnId: () => number;
  setWorkspaceCancelCurrent: (cancel: (() => void) | null) => void;

  // Explore navigation / state
  startExplore: (seed?: string) => void;
  setExploreMessages: (updater: ((prev: Message[]) => Message[]) | Message[]) => void;
  setExploreArtifacts: (artifacts: ExploreArtifacts | null) => void;
  setExploreArtifactEdit: (opts: {
    kind: 'candidateStatements' | 'assumptions' | 'examples' | 'counterexamples';
    /** Candidate statement key for non-candidate edits. */
    statementKey?: string;
    original: string;
    edited: string;
  }) => void;
  clearExploreArtifactEdits: () => void;
  bumpExploreTurnId: () => number;
  getExploreTurnId: () => number;
  setExploreCancelCurrent: (cancel: (() => void) | null) => void;
  promoteToProof: (statement: string) => Promise<void>;
  startExploreFromFailedProof: () => void;

  startProof: (problem: string, opts?: { force?: boolean }) => Promise<void>;
  retry: () => Promise<void>;
  editProblem: () => void;
  setMessages: (updater: ((prev: Message[]) => Message[]) | Message[]) => void;

  // Variant handling
  acceptSuggestedChange: () => void;
  clearSuggestion: () => void;
  clearRejection: () => void;

  // UI actions
  setIsChatOpen: (open: boolean | ((prev: boolean) => boolean)) => void;
  setIsHistoryOpen: (open: boolean | ((prev: boolean) => boolean)) => void;
  setViewMode: (mode: 'raw' | 'structured' | 'graph') => void;
  toggleStructuredView: () => void;

  /** Run whole-proof analysis for the current view (raw or structured). No-op in graph view. */
  analyzeCurrentProof: () => Promise<void>;

  /** Cancel an in-flight analysis run (best-effort: ignores late results). */
  cancelAnalyzeCurrentProof: () => void;

  // Raw proof
  setRawProof: (raw: string) => void;
  runDecomposition: () => Promise<void>;

  /** Request that the Raw Proof editor enters editing mode (focus textarea). */
  requestRawProofEdit: () => void;

  // Version helpers (used by UI)
  getCurrentRawBaseMajor: () => number | null;
  hasUserEditedStructuredForBaseMajor: (baseMajor: number) => boolean;
  hasUserEditedStructuredForCurrentRaw: () => boolean;

  /** Snapshot a manual edit to a structured proof as a new structured minor version (N.k+1). */
  snapshotStructuredEdit: (updates: Partial<ProofVersion>) => void;

  /** Ensure graphData exists for a structured proof version (silent + deduped). */
  ensureGraphForVersion: (versionId: string) => Promise<void>;

  // Proof version management
  setActiveVersionIndex: (index: number) => void;
  addProofVersion: (version: Omit<ProofVersion, 'timestamp'>) => void;
  updateCurrentProofVersion: (updates: Partial<ProofVersion>) => void;
  /**
   * Update non-versioned metadata for the currently active proof version.
   *
   * This is intended for ephemeral data like validation results and graph data.
   * It MUST NOT append a new proof version.
   */
  updateCurrentProofMeta: (updates: Partial<ProofVersion>) => void;
  updateCurrentStepValidation: (opts: {
    stepIndex: number;
    result?: ProofValidationResult;
  }) => void;
  clearLastEditedStep: () => void;

  /**
   * Delete a proof version by id.
   *
   * Deletion rules:
   * - Deleting a raw version deletes all versions for that baseMajor.
   * - Deleting a structured version deletes only that entry, unless it's the only
   *   structured version for that baseMajor (in which case we delete the entire group).
   */
  deleteProofVersion: (id: string) => void;

  // Navigation
  goBack: () => void;

  proof: () => ProofVersion;
}

let decomposeRunId = 0;

const initialState: StoreData = {
  view: 'home',
  problem: null,
  lastProblem: null,
  messages: [],

  chatDraft: '',
  chatDraftNonce: 0,

  exploreDraft: '',
  exploreDraftNonce: 0,

  exploreSeed: null,
  exploreMessages: [],
  exploreArtifacts: null,
  exploreArtifactEdits: {
    candidateStatements: {},
    perStatement: {},
  },
  exploreTurnId: 0,
  cancelExploreCurrent: null,

  loading: false,
  error: null,
  errorDetails: null,
  errorCode: null,
  // proof display UI defaults
  isChatOpen: false,
  isHistoryOpen: false,
  viewMode: 'raw',
  // proof review/history defaults
  proofHistory: [],

  // Raw proof + background decomposition state
  rawProof: '',
  rawProofEditNonce: 0,
  attemptSummary: null,
  isDecomposing: false,
  decomposeError: null,
  stepsReadyNonce: 0,
  decomposeMeta: null,
  decomposedRaw: null,

  activeVersionIdx: 0,
  pendingSuggestion: null,
  pendingRejection: null,
  progressLog: [],
  cancelCurrent: null,
  liveDraft: '',
  isDraftStreaming: false,

  isAnalyzingProof: false,
  analyzeProofRunId: 0,

  workspaceDoc: '',
  workspaceMessages: [],
  workspaceDraft: '',
  workspaceDraftNonce: 0,
  isWorkspaceChatOpen: true,
  workspaceRightPanelTab: 'chat',
  workspaceRightPanelWidth: 448, // 28rem default

  workspaceArtifacts: null,
  workspaceArtifactEdits: {
    candidateStatements: {},
    perStatement: {},
  },
  workspaceTurnId: 0,
  cancelWorkspaceCurrent: null,
};

export const useAppStore = create<AppState>((set, get) => ({
  ...initialState,

  goHome: () => set({ view: 'home' }),

  setChatDraft: (text, opts) => {
    const t = String(text ?? '');
    set((s) => ({
      chatDraft: t,
      chatDraftNonce: (s.chatDraftNonce || 0) + 1,
      // In proof mode, optionally open the chat panel.
      isChatOpen: opts?.open ? true : s.isChatOpen,
    }));
  },

  setExploreDraft: (text) => {
    const t = String(text ?? '');
    set((s) => ({
      exploreDraft: t,
      exploreDraftNonce: (s.exploreDraftNonce || 0) + 1,
    }));
  },

  startWorkspace: (seed?: string) => {
    const doc = String(seed ?? '').trim();
    set((s) => ({
      view: 'workspace',
      workspaceDoc: doc || s.workspaceDoc || '',
      // keep conversation by default
      workspaceMessages: s.workspaceMessages,
    }));
  },

  newWorkspace: () => {
    set({
      view: 'workspace',
      workspaceDoc: '',
      workspaceMessages: [],
      workspaceDraft: '',
      workspaceDraftNonce: 0,
      isWorkspaceChatOpen: true,
      workspaceRightPanelTab: 'chat',
      workspaceRightPanelWidth: 448,
    });
  },

  setWorkspaceDoc: (doc) => set({ workspaceDoc: String(doc ?? '') }),

  setWorkspaceDraft: (text, opts) => {
    const t = String(text ?? '');
    set((s) => ({
      workspaceDraft: t,
      workspaceDraftNonce: (s.workspaceDraftNonce || 0) + 1,
      isWorkspaceChatOpen: opts?.open ? true : s.isWorkspaceChatOpen,
    }));
  },

  setWorkspaceRightPanelTab: (tab) => set({ workspaceRightPanelTab: tab }),

  setWorkspaceRightPanelWidth: (widthPx) => {
    const clamp = (n: number, a: number, b: number) => Math.max(a, Math.min(b, n));
    // Keep it within a sensible range.
    const next = clamp(Number(widthPx) || 0, 280, 720);
    set({ workspaceRightPanelWidth: next });
  },

  setWorkspaceArtifacts: (artifacts) => set({ workspaceArtifacts: artifacts }),

  setWorkspaceArtifactEdit: ({ kind, statementKey, original, edited }) => {
    const o = (original ?? '').trim();
    if (!o) return;
    const e = (edited ?? '').trim();

    if (kind === 'candidateStatements') {
      set((state) => ({
        workspaceArtifactEdits: {
          ...state.workspaceArtifactEdits,
          candidateStatements: {
            ...state.workspaceArtifactEdits.candidateStatements,
            [o]: e,
          },
        },
      }));
      return;
    }

    const sk = (statementKey ?? '').trim();
    if (!sk) return;

    set((state) => {
      const prevForStmt = state.workspaceArtifactEdits.perStatement[sk] ?? {
        assumptions: {},
        examples: {},
        counterexamples: {},
      };

      return {
        workspaceArtifactEdits: {
          ...state.workspaceArtifactEdits,
          perStatement: {
            ...state.workspaceArtifactEdits.perStatement,
            [sk]: {
              ...prevForStmt,
              [kind]: {
                ...prevForStmt[kind],
                [o]: e,
              },
            },
          },
        },
      };
    });
  },

  bumpWorkspaceTurnId: () => {
    const next = get().workspaceTurnId + 1;
    set({ workspaceTurnId: next });
    return next;
  },

  getWorkspaceTurnId: () => get().workspaceTurnId,

  setWorkspaceCancelCurrent: (cancel) => set({ cancelWorkspaceCurrent: cancel }),

  setWorkspaceMessages: (updater) => {
    if (typeof updater === 'function') {
      set((state) => ({
        workspaceMessages: (updater as (prev: Message[]) => Message[])(state.workspaceMessages),
      }));
    } else {
      set({ workspaceMessages: updater });
    }
  },

  setIsWorkspaceChatOpen: (open) => {
    if (typeof open === 'function') {
      set((s) => ({ isWorkspaceChatOpen: (open as any)(s.isWorkspaceChatOpen) }));
    } else {
      set({ isWorkspaceChatOpen: open });
    }
  },

  ensureGraphForVersion: async (versionId: string) => {
    try {
      const state = get();
      const idx = state.proofHistory.findIndex((v) => v.id === versionId);
      if (idx < 0) return;
      const v = state.proofHistory[idx];
      if (!v || v.type !== 'structured') return;
      const steps = v.sublemmas || [];
      if (steps.length === 0) return;

      const goalStatement = (state.problem || '').trim();
      if (!goalStatement) return;

      const hashString = (input: string): string => {
        try {
          let h = 0;
          for (let i = 0; i < input.length; i++) {
            h = (h * 31 + input.charCodeAt(i)) | 0;
          }
          return `h${h}`;
        } catch {
          return 'h0';
        }
      };

      const graphHash = hashString(
        JSON.stringify({
          goalStatement,
          steps: steps.map((s) => ({ title: s.title, statement: s.statement })),
        }),
      );

      // Dedup: if we already computed for this exact input, no-op.
      if (v.graphData && v.graphHash === graphHash) return;

      const result = await generateProofGraphForGoalAction(goalStatement, steps);
      if ((result as any)?.success !== true) return;

      const { nodes, edges } = result as any;
      const normalizedNodes = (nodes as any[]).map((n) => {
        const m = String(n.id || '').match(/step-(\d+)/);
        const stepIdx = m ? parseInt(m[1], 10) - 1 : -1;
        const content =
          n.id === 'goal'
            ? goalStatement
            : stepIdx >= 0 && stepIdx < steps.length
              ? steps[stepIdx].statement
              : '';
        return {
          ...n,
          label: n.id === 'goal' ? 'Goal' : n.label,
          content,
        };
      });

      // Only commit if the version still exists and hash still matches.
      set((s) => {
        const j = s.proofHistory.findIndex((x) => x.id === versionId);
        if (j < 0) return s;
        const cur = s.proofHistory[j];
        if (!cur || cur.type !== 'structured') return s;
        return {
          ...s,
          proofHistory: s.proofHistory.map((x) =>
            x.id === versionId
              ? {
                ...x,
                graphData: { nodes: normalizedNodes, edges },
                graphHash,
              }
              : x,
          ),
        };
      });
    } catch {
      // silent failure
    }
  },

  cancelAnalyzeCurrentProof: () =>
    set((s) => ({
      isAnalyzingProof: false,
      // bump run id so late results from an older run get ignored
      analyzeProofRunId: (s.analyzeProofRunId || 0) + 1,
    })),

  analyzeCurrentProof: async () => {
    const state = get();
    const proof = state.proof();

    // Mark analysis as running and capture a run id for cancellation.
    const myRun = (state.analyzeProofRunId || 0) + 1;
    set({ isAnalyzingProof: true, analyzeProofRunId: myRun });

    // No analysis in graph view.
    if (state.viewMode === 'graph') {
      // ensure UI doesn't get stuck
      set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
      return;
    }

    const problem = (state.problem || '').trim();
    if (!problem) {
      set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
      return;
    }

    const isRawMode = state.viewMode === 'raw' || proof.type === 'raw';

    // Avoid pointless calls.
    if (isRawMode) {
      const raw = (state.rawProof || '').trim();
      if (!raw) {
        set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
        return;
      }
    } else {
      if (!proof.sublemmas || proof.sublemmas.length === 0) {
        set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
        return;
      }
    }

    const hashString = (input: string): string => {
      try {
        let h = 0;
        for (let i = 0; i < input.length; i++) {
          h = (h * 31 + input.charCodeAt(i)) | 0;
        }
        return `h${h}`;
      } catch {
        return 'h0';
      }
    };

    const computeSourceHash = () => {
      if (isRawMode) return hashString((state.rawProof || '').trim());
      const steps = (proof.sublemmas || []).map((s) => ({ title: s.title, statement: s.statement, proof: s.proof }));
      return hashString(JSON.stringify(steps));
    };

    const sourceHash = computeSourceHash();
    const last = proof.validationResult;
    if (last?.sourceType === (isRawMode ? 'raw' : 'structured') && last?.sourceHash === sourceHash) {
      set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
      return;
    }

    // Clear existing result so UI can show "fresh" state.
    get().updateCurrentProofMeta({ validationResult: undefined });

    try {
      const { validateProofAction, validateRawProofAction } = await import('@/app/actions');
      const result = isRawMode
        ? await validateRawProofAction(problem, state.rawProof)
        : await validateProofAction(problem, proof.sublemmas);

      // Ignore late results if cancelled.
      if (get().analyzeProofRunId !== myRun) return;

      if ((result as any)?.success) {
        get().updateCurrentProofMeta({
          validationResult: {
            isValid: (result as any).isValid || false,
            isError: false,
            feedback: (result as any).feedback || 'No feedback provided.',
            timestamp: new Date(),
            model: undefined as any,
            sourceType: isRawMode ? 'raw' : 'structured',
            sourceHash,
          },
          lastEditedStepIdx: null,
        });
        get().clearLastEditedStep();
      } else {
        const friendly =
          (result as any)?.error ||
          'Adjoint’s connection to the model was interrupted, please go back and retry.';
        get().updateCurrentProofMeta({
          validationResult: {
            isError: true,
            timestamp: new Date(),
            feedback: friendly,
          },
        });
      }
    } catch (e: any) {
      if (get().analyzeProofRunId !== myRun) return;
      const friendly = e?.message || 'Adjoint’s connection to the model was interrupted, please go back and retry.';
      get().updateCurrentProofMeta({
        validationResult: {
          isError: true,
          timestamp: new Date(),
          feedback: friendly,
        },
      });
    } finally {
      // Only clear running state if this run is still current.
      set((s) => (s.analyzeProofRunId === myRun ? { isAnalyzingProof: false } : ({} as any)));
    }
  },

  requestRawProofEdit: () => set((s) => ({ rawProofEditNonce: (s.rawProofEditNonce || 0) + 1 })),

  startExplore: (seed?: string) => {
    // Cancel any in-flight explore stream
    const cancel = get().cancelExploreCurrent || null;
    if (cancel) {
      try { cancel(); } catch { }
    }

    const trimmed = seed?.trim() ? seed.trim() : null;

    // If a new seed is provided (coming from Home), start a fresh explore session.
    if (trimmed) {
      set({
        view: 'explore',
        exploreSeed: trimmed,
        exploreMessages: [],
        exploreArtifacts: null,
        exploreArtifactEdits: {
          candidateStatements: {},
          perStatement: {},
        },
        exploreTurnId: 0,
      });
      return;
    }

    // Otherwise, preserve any existing thread (direct revisit of /explore).
    set({
      view: 'explore',
      exploreSeed: get().exploreSeed,
      exploreMessages: get().exploreMessages.length ? get().exploreMessages : [],
      exploreArtifacts: get().exploreArtifacts,
    });
  },

  setExploreMessages: (updater) => {
    if (typeof updater === 'function') {
      set((state) => ({
        exploreMessages: (updater as (prev: Message[]) => Message[])(state.exploreMessages),
      }));
    } else {
      set({ exploreMessages: updater });
    }
  },

  setExploreArtifacts: (artifacts) => set({ exploreArtifacts: artifacts }),

  setExploreArtifactEdit: ({ kind, statementKey, original, edited }) => {
    const o = (original ?? '').trim();
    if (!o) return;
    const e = (edited ?? '').trim();

    if (kind === 'candidateStatements') {
      set((state) => ({
        exploreArtifactEdits: {
          ...state.exploreArtifactEdits,
          candidateStatements: {
            ...state.exploreArtifactEdits.candidateStatements,
            [o]: e,
          },
        },
      }));
      return;
    }

    const sk = (statementKey ?? '').trim();
    if (!sk) return;

    set((state) => {
      const prevForStmt = state.exploreArtifactEdits.perStatement[sk] ?? {
        assumptions: {},
        examples: {},
        counterexamples: {},
      };

      return {
        exploreArtifactEdits: {
          ...state.exploreArtifactEdits,
          perStatement: {
            ...state.exploreArtifactEdits.perStatement,
            [sk]: {
              ...prevForStmt,
              [kind]: {
                ...prevForStmt[kind],
                [o]: e,
              },
            },
          },
        },
      };
    });
  },

  clearExploreArtifactEdits: () =>
    set({
      exploreArtifactEdits: {
        candidateStatements: {},
        perStatement: {},
      },
    }),

  bumpExploreTurnId: () => {
    const next = get().exploreTurnId + 1;
    set({ exploreTurnId: next });
    return next;
  },

  getExploreTurnId: () => get().exploreTurnId,

  setExploreCancelCurrent: (cancel) => set({ cancelExploreCurrent: cancel }),

  promoteToProof: async (statement: string) => {
    const trimmed = statement.trim();
    if (!trimmed) return;
    // Keep explore context in store; switch view to proof via startProof
    await get().startProof(trimmed);
  },

  startExploreFromFailedProof: () => {
    const problem = (get().problem || '').trim();
    const original = (get().lastProblem || '').trim();
    const draft = (get().liveDraft || '').trim();

    const userContent = original || problem;
    const seededMessages: Message[] = [];

    if (userContent) {
      seededMessages.push({ role: 'user', content: userContent });
    }
    if (draft) {
      seededMessages.push({ role: 'assistant', content: draft });
    }

    set({
      view: 'explore',
      exploreSeed: userContent || null,
      exploreMessages: seededMessages,
      exploreArtifacts: null,
      exploreArtifactEdits: {
        candidateStatements: {},
        perStatement: {},
      },
      exploreTurnId: 0,
    });
  },

  startProof: async (problem: string, opts?: { force?: boolean }) => {
    const trimmed = problem.trim();
    if (!trimmed) return;

    // Initialize state for a new proof run
    // Cancel any in-flight decomposition runs by bumping the run id.
    decomposeRunId += 1;

    set({
      view: 'proof',
      problem: trimmed,
      lastProblem: trimmed,
      messages: [],
      loading: true,
      error: null,
      errorDetails: null,
      errorCode: null,

      // New split-phase proof state
      viewMode: 'raw',
      rawProof: '',
      attemptSummary: null,
      isDecomposing: false,
      decomposeError: null,
      stepsReadyNonce: 0,
      decomposeMeta: null,
      decomposedRaw: null,

      pendingSuggestion: null,
      pendingRejection: null,
      proofHistory: [],
      activeVersionIdx: 0,
      progressLog: ['Starting proof attempt...'],
      cancelCurrent: null,
      liveDraft: '',
      isDraftStreaming: false,
    });

    const appendLog = (line: string) => set((s) => ({ progressLog: [...s.progressLog, line] }));

    // Fallback non-streaming implementation (existing behavior)
    const runNonStreaming = async () => {
      await new Promise((r) => setTimeout(r, 50));
      const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] attemptProof(start, non-stream) len=', trimmed.length);
      const attempt = opts?.force
        ? await attemptProofActionForce(trimmed)
        : await attemptProofAction(trimmed);
      const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] attemptProof done ms=', t1 - t0, 'success=', (attempt as any)?.success);

      if (!attempt.success) {
        set({ loading: false, error: attempt.error || 'Failed to attempt proof.' });
        return;
      }

      if (attempt.status === 'FAILED') {
        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        set({
          loading: false,
          error: null,
          pendingRejection: { explanation: attempt.explanation || 'No details provided.' },
          proofHistory: [rawVersion],
          activeVersionIdx: 0,
        });
        return;
      }

      const d0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const decomp = await decomposeRawProofAction(attempt.rawProof || '');
      const d1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] decomposeRawProof done ms=', d1 - d0, 'success=', (decomp as any)?.success);

      if (!decomp.success) {
        // Decomposition is not fatal in the new split-phase UX.
        // Keep the proof UI alive (Raw Proof is still available) and surface a non-blocking error.
        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        set({
          loading: false,
          decomposeError: decomp.error || 'Failed to decompose the drafted proof.',
          proofHistory: [rawVersion],
          activeVersionIdx: 0,
        });
        return;
      }

      if (attempt.status === 'PROVED_AS_IS') {
        const steps: Sublemma[] = (decomp.sublemmas && decomp.sublemmas.length > 0)
          ? (decomp.sublemmas as Sublemma[])
          : ([{
            title: 'Proof',
            statement: decomp.provedStatement,
            proof: (decomp as any).normalizedProof || attempt.rawProof || 'Proof unavailable.',
          }] as Sublemma[]);
        console.debug('[UI][AppStore] provedAsIs steps', steps.length);
        const assistantMessage: Message = {
          role: 'assistant',
          content:
            `I've broken down the proof into the following steps:\n\n` +
            steps.map((s: Sublemma) => `**${s.title}:** ${s.statement}`).join('\n\n'),
        };

        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        const structuredVersion = makeStructuredVersion(get().proofHistory, rawVersion.baseMajor, steps, {
          provedStatement: decomp.provedStatement,
          normalizedProof: (decomp as any).normalizedProof || '',
        }, { userEdited: false, derived: true });

        set({
          messages: [assistantMessage],
          loading: false,
          error: null,
          proofHistory: [rawVersion, structuredVersion],
          activeVersionIdx: 1,
          decomposedRaw: rawContent,
        });

        // Silent: compute dependency graph for the new structured version.
        setTimeout(() => {
          void get().ensureGraphForVersion(structuredVersion.id);
        }, 0);
        return;
      }

      // PROVED_VARIANT or similar: keep suggestion but ensure raw version exists
      const rawContent = attempt.rawProof || '';
      const rawVersion = makeRawVersion(get().proofHistory, rawContent);
      set({
        loading: false,
        error: null,
        pendingSuggestion: {
          suggested: attempt.finalStatement || (decomp as any).provedStatement,
          variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING',
          provedStatement: (decomp as any).provedStatement,
          sublemmas: (decomp as any).sublemmas as Sublemma[],
          explanation: attempt.explanation,
          normalizedProof: (decomp as any).normalizedProof,
          rawProof: attempt.rawProof || undefined,
        },
        proofHistory: [rawVersion],
        activeVersionIdx: 0,
      });
    };

    // Try token streaming first; fallback to metadata-only SSE, then non-streaming
    if (typeof window !== 'undefined' && 'EventSource' in window) {
      const runMetadataSSE = async () => {
        try {
          const url2 = `/api/proof/attempt-sse?problem=${encodeURIComponent(trimmed)}`;
          const es2 = new EventSource(url2);
          let finished2 = false;
          set({ cancelCurrent: () => { try { es2.close(); } catch { } } });

          es2.addEventListener('progress', (ev: MessageEvent) => {
            try {
              const data = JSON.parse(ev.data || '{}');
              if (data?.phase === 'attempt.start') appendLog('Attempting proof...');
              if (data?.phase === 'decompose.start') appendLog('Decomposing proof....');
            } catch { }
          });
          es2.addEventListener('attempt', (ev: MessageEvent) => {
            try {
              const data = JSON.parse(ev.data || '{}');
              if (data?.status === 'FAILED') {
                appendLog("Couldn't prove the statement as written. Showing explanation...");
              } else if (data?.status === 'PROVED_VARIANT') {
                appendLog('Proof generated for a revised statement....');
              } else {
                appendLog(`Model produced a proof (len ~${data?.rawProofLen ?? 0})...`);
              }
            } catch { }
          });
          es2.addEventListener('decompose', (ev: MessageEvent) => {
            try { const data = JSON.parse(ev.data || '{}'); appendLog(`Decomposed into ${data?.sublemmasCount ?? 0} step(s)....`); } catch { }
          });
          es2.addEventListener('server-error', (ev: MessageEvent) => {
            if (finished2) return; finished2 = true;
            try {
              const data = JSON.parse(ev.data || '{}');
              set({
                loading: false,
                error: data?.error || 'Unexpected server error.',
                errorDetails: data?.detail ?? null,
                errorCode: data?.code ?? null,
              });
            } catch {
              set({ loading: false, error: 'Unexpected server error.', errorDetails: null, errorCode: null });
            }
            try { es2.close(); } catch { }
            set({ cancelCurrent: null });
          });
          es2.addEventListener('done', (ev: MessageEvent) => {
            if (finished2) return; finished2 = true;
            try {
              const data = JSON.parse(ev.data || '{}');
              const attempt = data?.attempt; const decomp = data?.decompose;
              if (!attempt) { set({ loading: false, error: 'Malformed SSE response.' }); return; }
              if (attempt.status === 'FAILED') {
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({
                  loading: false,
                  error: null,
                  pendingRejection: { explanation: attempt.explanation || 'No details provided.' },
                  proofHistory: [rawVersion],
                  activeVersionIdx: 0,
                });
              } else if (!decomp) {
                // Decomposition failure is not fatal; allow the user to view/edit Raw Proof.
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({ loading: false, decomposeError: 'Failed to decompose the drafted proof.', proofHistory: [rawVersion], activeVersionIdx: 0 });
              } else if (attempt.status === 'PROVED_AS_IS') {
                const steps: Sublemma[] = (decomp.sublemmas && decomp.sublemmas.length > 0) ? (decomp.sublemmas as Sublemma[]) : ([{ title: 'Proof', statement: decomp.provedStatement, proof: (decomp as any).normalizedProof || attempt.rawProof || 'Proof unavailable.', }] as Sublemma[]);
                const assistantMessage: Message = { role: 'assistant', content: `I've broken down the proof into the following steps:\n\n` + steps.map((s: Sublemma) => `**${s.title}:** ${s.statement}`).join('\n\n'), };

                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                const structuredVersion = makeStructuredVersion(get().proofHistory, rawVersion.baseMajor, steps, { provedStatement: decomp.provedStatement, normalizedProof: (decomp as any).normalizedProof || '' }, { userEdited: false, derived: true });

                set({ messages: [assistantMessage], loading: false, error: null, proofHistory: [rawVersion, structuredVersion], activeVersionIdx: 1, decomposedRaw: attempt.rawProof || '' });

                // Silent: compute dependency graph for the new structured version.
                setTimeout(() => {
                  void get().ensureGraphForVersion(structuredVersion.id);
                }, 0);
              } else {
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({ loading: false, error: null, pendingSuggestion: { suggested: attempt.finalStatement || decomp.provedStatement, variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING', provedStatement: decomp.provedStatement, sublemmas: decomp.sublemmas as Sublemma[], explanation: attempt.explanation, normalizedProof: (decomp as any).normalizedProof, rawProof: attempt.rawProof || undefined, }, proofHistory: [rawVersion], activeVersionIdx: 0 });
              }
            } catch (e) { set({ loading: false, error: e instanceof Error ? e.message : 'Unexpected error.' }); }
            finally { try { es2.close(); } catch { } set({ cancelCurrent: null }); }
          });
          es2.onerror = () => { try { es2.close(); } catch { } set({ cancelCurrent: null }); appendLog('Metadata stream lost. Falling back to non-streaming...'); runNonStreaming(); };
        } catch { await runNonStreaming(); }
      };

      try {
        const url = `/api/proof/attempt-stream?problem=${encodeURIComponent(trimmed)}`;
        const es = new EventSource(url);
        let finished = false;
        let gotDelta = false;
        set({ cancelCurrent: () => { try { es.close(); } catch { } } });
        set({ isDraftStreaming: true, liveDraft: '' });

        es.addEventListener('model.start', (ev: MessageEvent) => {
          try { const data = JSON.parse(ev.data || '{}'); appendLog(`Using ${data?.provider}/${data?.model}...`); } catch { }
        });
        es.addEventListener('model.switch', (ev: MessageEvent) => {
          try { const d = JSON.parse(ev.data || '{}'); if (d?.to) appendLog(`Switched model to ${d.to}...`); } catch { }
        });
        es.addEventListener('model.delta', (ev: MessageEvent) => {
          try { const data = JSON.parse(ev.data || '{}'); const t = data?.text || ''; if (t) { if (!gotDelta) { appendLog('Receiving model output...'); gotDelta = true; } set((s) => ({ liveDraft: s.liveDraft + t })); } } catch { }
        });
        es.addEventListener('model.end', () => {
          // Draft complete, but we intentionally do NOT reveal it yet.
          // We first wait for classification (event: done) so we can show
          // PROVED_VARIANT suggestions *before* showing a tentative proof.
          set({ isDraftStreaming: false });
          appendLog('Proof draft completed....');
          appendLog('Classifying draft...');
        });
        es.addEventListener('classify.result', (ev: MessageEvent) => {
          try {
            const d = JSON.parse(ev.data || '{}');
            const st = d?.status;
            if (st === 'PROVED_VARIANT') {
              appendLog('Proof generated for a revised statement....');
            } else if (st === 'FAILED') {
              appendLog("Draft doesn't prove the statement as written. Showing explanation...");
            }
          } catch { }
        });

        // attempt-stream no longer performs decomposition server-side.
        // We do client-side decomposition only on explicit user request.

        es.addEventListener('server-error', (ev: MessageEvent) => {
          if (finished) return; finished = true;
          let friendly = 'Token stream failed.';
          let detail: string | null = null;
          let code: string | null = null;
          try {
            const data = JSON.parse(ev.data || '{}');
            if (data?.error) friendly = data.error; // already friendly from server
            if (data?.detail) detail = data.detail;
            if (data?.code) code = data.code;
          } catch { }
          try { es.close(); } catch { }
          set({ cancelCurrent: null, isDraftStreaming: false, errorDetails: detail, errorCode: code });
          appendLog(friendly + ' Falling back to metadata stream...');
          runMetadataSSE();
        });

        es.addEventListener('done', (ev: MessageEvent) => {
          if (finished) return; finished = true;
          try {
            const data = JSON.parse(ev.data || '{}');
            const attempt = data?.attempt;
            if (!attempt) {
              set({ loading: false, error: 'Malformed stream response.' });
              return;
            }

            // Cache classification outcome.
            set({
              attemptSummary: {
                status: attempt.status,
                finalStatement: attempt.finalStatement ?? null,
                variantType: attempt.variantType ?? null,
                explanation: attempt.explanation || '',
              },
            });

            // IMPORTANT UX RULE:
            // - If PROVED_VARIANT, show the suggestion FIRST and only show the tentative proof after Accept.
            // - Otherwise, reveal the tentative proof immediately.
            const raw = ((attempt.rawProof || get().liveDraft) ?? '').trim();

            if (attempt.status === 'PROVED_VARIANT') {
              const suggested = (attempt.finalStatement || '').trim();
              if (suggested) {
                set({
                  loading: false,
                  pendingSuggestion: {
                    suggested,
                    variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING',
                    provedStatement: suggested,
                    sublemmas: [],
                    explanation: attempt.explanation || '',
                    rawProof: raw || undefined,
                    normalizedProof: undefined,
                  },
                });
              } else {
                // Fallback: no suggested statement; just show the draft.
                const rawVersion = makeRawVersion(get().proofHistory, raw);
                set((state) => ({
                  loading: false,
                  viewMode: 'raw',
                  rawProof: raw,
                  decomposeError: null,
                  isDecomposing: false,
                  proofHistory: [...state.proofHistory, rawVersion],
                  activeVersionIdx: state.proofHistory.length,
                }));
                lastSavedRaw = raw;
              }
              return;
            }

            // Reveal raw proof for PROVED_AS_IS and FAILED.
            if (raw.length > 0) {
              const rawVersion = makeRawVersion(get().proofHistory, raw);
              set((state) => ({
                loading: false,
                viewMode: 'raw',
                rawProof: raw,
                decomposeError: null,
                isDecomposing: false,
                proofHistory: [...state.proofHistory, rawVersion],
                activeVersionIdx: state.proofHistory.length,
                pendingRejection:
                  attempt.status === 'FAILED'
                    ? { explanation: attempt.explanation || 'No details provided.' }
                    : null,
              }));
              lastSavedRaw = raw;
            } else {
              set({
                loading: false,
                pendingRejection:
                  attempt.status === 'FAILED'
                    ? { explanation: attempt.explanation || 'No details provided.' }
                    : null,
              });
            }
          } catch (e) {
            set({ loading: false, error: e instanceof Error ? e.message : 'Unexpected error.' });
          } finally {
            try { es.close(); } catch { }
            set({ cancelCurrent: null, isDraftStreaming: false });
          }
        });

        es.onerror = () => {
          if (finished) return; finished = true; try { es.close(); } catch { }
          set({ cancelCurrent: null, isDraftStreaming: false });
          appendLog('Token stream connection lost. Falling back to metadata stream...');
          runMetadataSSE();
        };
      } catch (e) {
        appendLog('Token streaming not available. Falling back to metadata stream...');
        await runMetadataSSE();
      }
    } else {
      await runNonStreaming();
    }
  },

  setMessages: (updater) => {
    if (typeof updater === 'function') {
      set((state) => ({
        messages: (updater as (prev: Message[]) => Message[])(state.messages),
      }));
    } else {
      set({ messages: updater });
    }
  },

  reset: () => {
    const cancel = get().cancelCurrent || null;
    if (cancel) {
      try { cancel(); } catch { }
    }
    const cancelExplore = get().cancelExploreCurrent || null;
    if (cancelExplore) {
      try { cancelExplore(); } catch { }
    }
    set((state) => ({
      ...initialState,
      // Keep lastProblem for convenience.
      lastProblem: state.lastProblem,
      // Keep workspace doc + chat so reset doesn't feel destructive.
      workspaceDoc: state.workspaceDoc,
      workspaceMessages: state.workspaceMessages,
      workspaceDraft: state.workspaceDraft,
      workspaceDraftNonce: state.workspaceDraftNonce,
      isWorkspaceChatOpen: state.isWorkspaceChatOpen,
    }));
  },

  // Additional actions
  retry: async () => {
    const p = get().lastProblem;
    if (p) {
      await get().startProof(p, { force: true });
    }
  },
  editProblem: () => {
    set((state) => ({
      ...state,
      view: 'home',
      loading: false,
      error: null,
      errorDetails: null,
      errorCode: null,
      pendingSuggestion: null,
    }));
  },

  // UI actions
  setIsChatOpen: (open) => {
    if (typeof open === 'function') {
      set((state) => ({
        isChatOpen: open(state.isChatOpen),
      }));
    } else {
      set({ isChatOpen: open });
    }
  },
  setIsHistoryOpen: (open) => {
    if (typeof open === 'function') {
      set((state) => ({
        isHistoryOpen: open(state.isHistoryOpen),
      }));
    } else {
      set({ isHistoryOpen: open });
    }
  },
  setViewMode: (mode) =>
    set((state) => {
      if (state.viewMode === mode) return state;

      // If the user changes the proof view, hide any previous analysis output and
      // cancel any in-flight analysis run (best-effort).
      const clearedHistory = state.proofHistory.map((v, idx) =>
        idx === state.activeVersionIdx ? { ...v, validationResult: undefined } : v,
      );

      const current = state.proofHistory[state.activeVersionIdx];
      const baseMajor = current?.baseMajor;

      const pickLast = (predicate: (v: ProofVersion) => boolean): number | null => {
        for (let i = state.proofHistory.length - 1; i >= 0; i--) {
          if (predicate(state.proofHistory[i])) return i;
        }
        return null;
      };

      let nextIdx = state.activeVersionIdx;
      if (mode === 'structured') {
        nextIdx =
          (baseMajor != null
            ? pickLast((v) => v.type === 'structured' && v.baseMajor === baseMajor)
            : null) ?? pickLast((v) => v.type === 'structured') ?? state.activeVersionIdx;
      } else if (mode === 'raw') {
        nextIdx =
          (baseMajor != null ? pickLast((v) => v.type === 'raw' && v.baseMajor === baseMajor) : null) ??
          pickLast((v) => v.type === 'raw') ??
          state.activeVersionIdx;
      }

      const next = state.proofHistory[nextIdx];
      return {
        viewMode: mode,
        activeVersionIdx: nextIdx,
        rawProof: mode === 'raw' ? (next?.content ?? state.rawProof) : state.rawProof,

        // cancel analysis + clear analysis result on view change
        isAnalyzingProof: false,
        analyzeProofRunId: (state.analyzeProofRunId || 0) + 1,
        proofHistory: clearedHistory,
      };
    }),
  toggleStructuredView: () =>
    set((state) => ({ viewMode: state.viewMode === 'structured' ? 'raw' : 'structured' })),

  setRawProof: (raw) => {
    const next = raw ?? '';

    // Update editor state only. Do NOT mutate existing history entries.
    set((state) => {
      const cur = state.rawProof;
      if (cur === next) return state;
      const trimmedNext = (next || '').trim();
      const trimmedDecomposed = (state.decomposedRaw || '').trim();
      const decompositionIsStale = !!trimmedDecomposed && trimmedNext !== trimmedDecomposed;
      return {
        rawProof: next,
        decomposeError: null,
        decomposeMeta: null,
        decomposedRaw: decompositionIsStale ? null : state.decomposedRaw,
        pendingSuggestion: null,
      };
    });

    // Debounced autosave: append a new raw major version after 3s idle if content changed.
    // This guarantees every saved raw edit becomes a new history entry.
    try {
      if (typeof window !== 'undefined') {
        if (rawAutosaveTimer) window.clearTimeout(rawAutosaveTimer);
        rawAutosaveTimer = window.setTimeout(() => {
          const cur = (get().rawProof || '').trim();
          if (!cur) return;
          if (cur === lastSavedRaw) return;

          const history = get().proofHistory;

          // compute next raw major
          const maxMajor = history.reduce(
            (m, v) => (v.type === 'raw' ? Math.max(m, v.baseMajor) : m),
            0,
          );
          const nextMajor = (maxMajor || 0) + 1;

          get().addProofVersion({
            id: uuid(),
            type: 'raw',
            versionNumber: `${nextMajor}`,
            baseMajor: nextMajor,
            content: cur,
            sublemmas: [],
            userEdited: true,
            derived: false,
            graphData: undefined,
            validationResult: undefined,
            stepValidation: undefined,
            lastEditedStepIdx: null,
          } as any);

          lastSavedRaw = cur;
        }, 3000);
      }
    } catch {
      /* ignore timers in SSR */
    }

    // Note: decomposition is automatic for the initial AI draft (Phase B),
    // but we do NOT automatically decompose on every raw edit.
  },

  runDecomposition: async () => {
    const raw = (get().rawProof || '').trim();
    if (raw.length < 10) return;

    const myRun = ++decomposeRunId;
    set({ isDecomposing: true, decomposeError: null });

    try {
      const result = await decomposeRawProofAction(raw);
      if (decomposeRunId !== myRun) return;

      if (!result.success) {
        set({ isDecomposing: false, decomposeError: result.error || 'Failed to decompose proof.' });
        return;
      }

      const steps: Sublemma[] =
        (result.sublemmas && result.sublemmas.length > 0)
          ? (result.sublemmas as Sublemma[])
          : ([{
            title: 'Proof',
            statement: result.provedStatement,
            proof: (result as any).normalizedProof || raw || 'Proof unavailable.',
          }] as Sublemma[]);

      // Update decompose meta (used for toasts / context).
      // IMPORTANT: do NOT mutate existing versions here. Decomposition results are persisted
      // only by appending a new structured ProofVersion below.
      set((state) => ({
        isDecomposing: false,
        decomposeError: null,
        decomposeMeta: {
          provedStatement: result.provedStatement,
          normalizedProof: (result as any).normalizedProof || '',
        },
        decomposedRaw: raw,
        stepsReadyNonce: state.stepsReadyNonce + 1,
      }));

      // Create a new structured version.
      const history = get().proofHistory;

      // Determine which raw major this structured version should attach to.
      // Priority:
      // 1) If the currently active version is a raw entry, attach to its baseMajor (user restored a prior raw).
      // 2) Else if rawProof matches a saved raw entry, attach to that baseMajor.
      // 3) Else fall back to latest raw major.
      const active = get().proof();
      const baseMajor =
        (active?.type === 'raw' ? active.baseMajor : null) ??
        get().getCurrentRawBaseMajor() ??
        (getMaxRawMajor(history) || 0);

      const structuredVersion = makeStructuredVersion(
        history,
        baseMajor || 1,
        steps,
        {
          provedStatement: result.provedStatement,
          normalizedProof: (result as any).normalizedProof || '',
        },
        { userEdited: false, derived: true },
      );

      // Append a new structured version.
      // IMPORTANT: keep the user's currently selected version stable (this often runs in the background).
      set((state) => {
        const nextIdx = state.proofHistory.length;
        const shouldActivate = state.viewMode === 'structured';
        const next = { ...structuredVersion, timestamp: new Date() } as any;
        // Schedule silent auto-graph generation for the new structured version.
        setTimeout(() => {
          void get().ensureGraphForVersion(next.id);
        }, 0);
        return {
          proofHistory: [...state.proofHistory, next],
          activeVersionIdx: shouldActivate ? nextIdx : state.activeVersionIdx,
        };
      });
    } catch (e: any) {
      if (decomposeRunId !== myRun) return;
      set({ isDecomposing: false, decomposeError: e?.message || 'Failed to decompose proof.' });
    }
  },


  getCurrentRawBaseMajor: () => {
    const raw = (get().rawProof || '').trim();
    if (!raw) return null;
    const history = get().proofHistory;
    // Prefer exact content match, else fall back to max raw major.
    const exact = history
      .filter((v) => v.type === 'raw' && (v.content || '').trim() === raw)
      .map((v) => v.baseMajor);
    if (exact.length) return Math.max(...exact);
    const max = history.filter((v) => v.type === 'raw').map((v) => v.baseMajor);
    return max.length ? Math.max(...max) : null;
  },

  hasUserEditedStructuredForBaseMajor: (baseMajor: number) => {
    const history = get().proofHistory;
    return history.some(
      (v) => v.type === 'structured' && v.baseMajor === baseMajor && v.userEdited,
    );
  },

  hasUserEditedStructuredForCurrentRaw: () => {
    const base = get().getCurrentRawBaseMajor();
    if (!base) return false;
    return get().hasUserEditedStructuredForBaseMajor(base);
  },

  snapshotStructuredEdit: (updates) => {
    const cur = get().proof();
    if (!cur || cur.type !== 'structured') {
      // Not in structured mode; fall back to updating current.
      get().updateCurrentProofVersion({ ...updates, userEdited: true });
      return;
    }

    const history = get().proofHistory;
    const baseMajor = cur.baseMajor;

    const next = makeStructuredVersion(
      history,
      baseMajor,
      (updates.sublemmas as Sublemma[]) ?? cur.sublemmas,
      {
        provedStatement: updates.structured?.provedStatement ?? cur.structured?.provedStatement,
        normalizedProof: updates.structured?.normalizedProof ?? cur.structured?.normalizedProof,
      },
      { userEdited: true, derived: false },
    );

    // Carry over other fields from the current version unless overridden.
    get().addProofVersion({
      ...next,
      // Allow callers to override a subset
      ...updates,
      id: next.id,
      type: 'structured',
      baseMajor,
      versionNumber: next.versionNumber,
      userEdited: true,
      derived: false,
      sublemmas: (updates.sublemmas as Sublemma[]) ?? next.sublemmas,
      structured: {
        provedStatement: next.structured?.provedStatement,
        normalizedProof: next.structured?.normalizedProof,
        ...(updates.structured || {}),
      },
      content:
        updates.content ??
        next.structured?.normalizedProof ??
        (typeof cur.content === 'string' ? cur.content : ''),
      validationResult: updates.validationResult ?? undefined,
      stepValidation: updates.stepValidation,
      lastEditedStepIdx: updates.lastEditedStepIdx ?? null,
      graphData: updates.graphData,
    } as any);

    set({ viewMode: 'structured' });
  },

  acceptSuggestedChange: () => {
    const s = get().pendingSuggestion;
    if (!s) return;

    // When the suggestion is accepted, we reveal the tentative proof.
    // In streaming mode we might not have decomposed steps yet.
    const rawContent = (s.rawProof || '').trim();
    const provedStatement = (s.provedStatement || s.suggested || '').trim();

    // Ensure a raw version exists in history for this content (avoid bumping majors unnecessarily).
    const curHistory = get().proofHistory;
    let rawIdx = curHistory.findIndex(
      (v) => v.type === 'raw' && (v.content || '').trim() === rawContent,
    );

    let nextHistory = curHistory;
    let rawVersion: ProofVersion | null = rawIdx >= 0 ? curHistory[rawIdx] : null;

    if (!rawVersion) {
      rawVersion = makeRawVersion(curHistory, rawContent);
      nextHistory = [...curHistory, rawVersion];
      rawIdx = nextHistory.length - 1;
    }

    lastSavedRaw = rawContent;

    // Commit the accepted statement and reveal raw proof.
    // Important: only create a structured version immediately if we already have decomposed steps.
    // Otherwise, kick off background decomposition so Structured Proof gets real sublemmas.
    const hasSteps = Array.isArray(s.sublemmas) && s.sublemmas.length > 0;

    if (hasSteps) {
      const steps = s.sublemmas as Sublemma[];
      const structuredVersion = makeStructuredVersion(
        nextHistory,
        rawVersion.baseMajor,
        steps,
        {
          provedStatement,
          normalizedProof: s.normalizedProof || '',
        },
        { userEdited: false, derived: true },
      );

      set({
        problem: provedStatement,
        pendingSuggestion: null,
        viewMode: 'raw',
        rawProof: rawContent,
        proofHistory: [...nextHistory, structuredVersion],
        activeVersionIdx: rawIdx,
        decomposedRaw: rawContent,
        messages: [
          {
            role: 'assistant',
            content:
              `I've broken down the proof into the following steps:\n\n` +
              steps.map((x) => `**${x.title}:** ${x.statement}`).join('\n\n'),
          } as Message,
        ],
      });

      // Silent: compute dependency graph for the new structured version.
      setTimeout(() => {
        void get().ensureGraphForVersion(structuredVersion.id);
      }, 0);

      return;
    }

    // No steps available yet (streaming path): switch to raw immediately and decompose in background.
    set({
      problem: provedStatement,
      pendingSuggestion: null,
      viewMode: 'raw',
      rawProof: rawContent,
      proofHistory: nextHistory,
      activeVersionIdx: rawIdx,
      decomposedRaw: null,
      decomposeMeta: null,
      decomposeError: null,
      messages: [],
    });

    // Fire-and-forget: generates a proper structured version once ready.
    void get().runDecomposition();
  },

  clearSuggestion: () => set({ pendingSuggestion: null }),
  clearRejection: () => set({ pendingRejection: null }),

  // Go back to previous proof version (if any) and ensure steps view
  goBack: () =>
    set((state) => {
      const nextIdx = Math.max(0, state.activeVersionIdx - 1);
      return {
        activeVersionIdx: nextIdx,
        viewMode: 'structured',
      };
    }),

  /**
   * Restore a specific proof history entry.
   *
   * Important: selecting a version must also reconcile `viewMode` and `rawProof`
   * to avoid UI states like "Structured proof" with no steps when a raw version is active.
   */
  setActiveVersionIndex: (index) =>
    set((state) => {
      const nextIdx = Math.max(0, Math.min(index, state.proofHistory.length - 1));
      const next = state.proofHistory[nextIdx];
      if (!next) return state;

      // Default: switch to a sensible mode for the restored version type.
      // If we're currently in Graph view, keep Graph view while switching versions.
      // (Graph should render for whichever structured version is active.)
      const nextViewMode: StoreData['viewMode'] =
        state.viewMode === 'graph' ? 'graph' : next.type === 'raw' ? 'raw' : 'structured';

      // Ensure rawProof reflects the restored raw version.
      const nextRawProof = next.type === 'raw' ? (next.content ?? '') : state.rawProof;

      return {
        ...state,
        activeVersionIdx: nextIdx,
        viewMode: nextViewMode,
        rawProof: nextRawProof,
      };
    }),

  addProofVersion: (version) =>
    set((state) => {
      const next = { ...version, timestamp: new Date() } as any;
      const nextIdx = state.proofHistory.length;
      // Schedule silent auto-graph generation for structured versions.
      if (next.type === 'structured' && Array.isArray(next.sublemmas) && next.sublemmas.length > 0) {
        setTimeout(() => {
          void get().ensureGraphForVersion(next.id);
        }, 0);
      }
      return {
        proofHistory: [...state.proofHistory, next],
        activeVersionIdx: nextIdx,
      };
    }),

  updateCurrentProofMeta: (updates) =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, ...updates } : version,
      ),
    })),

  updateCurrentProofVersion: (updates) => {
    const cur = get().proofHistory[get().activeVersionIdx];
    if (!cur) return;

    // For raw/structured edits that should be "saved", we append a new version instead of mutating.
    // (Callers can still use updateCurrentProofVersion for truly ephemeral updates, but we prefer new versions.)
    if (cur.type === 'raw') {
      get().addProofVersion({
        ...cur,
        ...updates,
        id: uuid(),
        type: 'raw',
        // Raw edits always bump the major.
        versionNumber: `${(getMaxRawMajor(get().proofHistory) || 0) + 1}`,
        baseMajor: (getMaxRawMajor(get().proofHistory) || 0) + 1,
        content: typeof updates.content === 'string' ? updates.content : cur.content,
        userEdited: true,
        derived: false,
        sublemmas: [],
        graphData: undefined,
        validationResult: undefined,
        stepValidation: undefined,
        lastEditedStepIdx: null,
      } as any);
      lastSavedRaw = (typeof updates.content === 'string' ? updates.content : cur.content) || '';
      return;
    }

    if (cur.type === 'structured') {
      // Re-route to the existing structured snapshot helper.
      get().snapshotStructuredEdit(updates);
      return;
    }

    // Fallback: mutate (should be rare)
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, ...updates } : version,
      ),
    }));
  },

  updateCurrentStepValidation: ({ stepIndex, result }) =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) => {
        if (idx !== state.activeVersionIdx) return version;
        const next = { ...version };
        const prev = next.stepValidation || {};
        if (result) {
          next.stepValidation = { ...prev, [stepIndex]: result };
        } else {
          const { [stepIndex]: _omit, ...rest } = prev;
          next.stepValidation = rest;
        }
        return next;
      }),
    })),

  clearLastEditedStep: () =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, lastEditedStepIdx: null } : version,
      ),
    })),

  deleteProofVersion: (id: string) =>
    set((state) => {
      const history = state.proofHistory;
      const idx = history.findIndex((v) => v.id === id);
      if (idx < 0) return state;

      const target = history[idx];
      const baseMajor = target.baseMajor;

      // Determine deletion set.
      const structuredForMajor = history.filter(
        (v) => v.baseMajor === baseMajor && v.type === 'structured',
      );

      const deleteWholeGroup =
        target.type === 'raw' ||
        (target.type === 'structured' && structuredForMajor.length <= 1);

      const nextHistory = deleteWholeGroup
        ? history.filter((v) => v.baseMajor !== baseMajor)
        : history.filter((v) => v.id !== id);

      // If nothing left, reset proof-specific state to a safe empty.
      if (nextHistory.length === 0) {
        return {
          ...state,
          proofHistory: [],
          activeVersionIdx: 0,
          viewMode: 'raw',
          rawProof: '',
          decomposedRaw: null,
          decomposeMeta: null,
        };
      }

      // Pick next active index.
      // Prefer staying on the same numeric index; if we deleted something before it, shift left.
      let nextActive = state.activeVersionIdx;

      if (idx < state.activeVersionIdx) {
        nextActive = Math.max(0, state.activeVersionIdx - 1);
      }

      // If we deleted the active item (or group), clamp to nearest valid entry.
      nextActive = Math.max(0, Math.min(nextActive, nextHistory.length - 1));

      const next = nextHistory[nextActive];

      // Ensure viewMode makes sense.
      let nextViewMode: StoreData['viewMode'] = state.viewMode;
      if (nextViewMode !== 'graph') {
        nextViewMode = next.type === 'raw' ? 'raw' : 'structured';
      } else {
        // Graph mode requires structured; if we ended up on raw, fall back.
        if (next.type === 'raw') nextViewMode = 'raw';
      }

      // Keep rawProof in sync if we are on a raw version.
      const nextRawProof = next.type === 'raw' ? (next.content ?? '') : state.rawProof;

      // If we deleted the only structured for the currently decomposed raw, clear decomposition pointers.
      // (Prevents UI thinking "steps are ready" when no structured versions remain for that major.)
      const stillHasStructuredForMajor = nextHistory.some(
        (v) => v.baseMajor === baseMajor && v.type === 'structured',
      );

      const shouldClearDecomposition =
        deleteWholeGroup ||
        (target.type === 'structured' && !stillHasStructuredForMajor);

      return {
        ...state,
        proofHistory: nextHistory,
        activeVersionIdx: nextActive,
        viewMode: nextViewMode,
        rawProof: nextRawProof,
        decomposedRaw: shouldClearDecomposition ? null : state.decomposedRaw,
        decomposeMeta: shouldClearDecomposition ? null : state.decomposeMeta,
      };
    }),

  proof: () => get().proofHistory[get().activeVersionIdx],
}));
