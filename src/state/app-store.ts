'use client';

import { create } from 'zustand';
import { type Sublemma } from '@/ai/flows/llm-proof-decomposition';
import { type Message } from '@/components/chat/interactive-chat';
import { type GraphData } from '@/components/proof-graph';
import type { ExploreArtifacts } from '@/ai/exploration-assistant/exploration-assistant.schemas';
import { attemptProofAction, attemptProofActionForce, decomposeRawProofAction } from '@/app/actions';

export type View = 'home' | 'explore' | 'proof';

// Extended ProofVersion to support raw vs structured versions, numbering and metadata
export type ProofVersion = {
  id: string;
  type: 'raw' | 'structured';
  versionNumber: string; // e.g. "1" or "2.1"
  baseMajor: number; // major raw version this structured version belongs to
  sublemmas: Sublemma[];
  // Optional raw/serialized content for this version
  content?: string;
  // Optional structured payload (lightweight summary)
  structured?: {
    provedStatement?: string;
    normalizedProof?: string;
  };
  // Flags
  userEdited?: boolean; // true when user explicitly edited this version
  derived?: boolean; // true when auto-generated by decomposition
  timestamp: Date;
  /** Whole-proof analysis result (existing footer). */
  validationResult?: ProofValidationResult;
  /** Per-step analysis results keyed by 0-based step index. */
  stepValidation?: Record<number, ProofValidationResult>;
  /** Which step was last edited (for contextual CTA). */
  lastEditedStepIdx?: number | null;
  graphData?: GraphData;
};

export type PendingSuggestion = {
  suggested: string; // model-proposed final statement
  variantType: 'WEAKENING' | 'OPPOSITE';
  provedStatement: string; // extracted from raw proof decomposition
  sublemmas: Sublemma[]; // pre-decomposed steps for instant accept
  explanation: string;
  normalizedProof?: string; // full normalized proof text for fallback rendering
  rawProof?: string; // original raw proof text for fallback rendering
};
export type ProofValidationResult = {
  isError?: boolean;
  isValid?: boolean;
  feedback: string;
  timestamp: Date;
  model?: string;
  /** Used to prevent re-running analysis when the underlying proof input is unchanged. */
  sourceType?: 'raw' | 'structured';
  /** Hash of the proof input (raw text or structured steps) for de-duping. */
  sourceHash?: string;
};

// Lightweight UUID generator for client-side ids
const uuid = () => 'v' + Math.random().toString(36).slice(2, 9);

// Helpers to create version objects
const getMaxRawMajor = (history: ProofVersion[]) =>
  history.reduce((m, v) => (v.type === 'raw' ? Math.max(m, v.baseMajor) : m), 0);

const makeRawVersion = (history: ProofVersion[], content: string) => {
  const nextMajor = (getMaxRawMajor(history) || 0) + 1;
  return {
    id: uuid(),
    type: 'raw' as const,
    versionNumber: `${nextMajor}`,
    baseMajor: nextMajor,
    content,
    sublemmas: [] as Sublemma[],
    userEdited: true,
    derived: false,
    timestamp: new Date(),
    validationResult: undefined,
    stepValidation: undefined,
    lastEditedStepIdx: null,
    graphData: undefined,
  } as ProofVersion;
};

const makeStructuredVersion = (
  history: ProofVersion[],
  baseMajor: number,
  steps: Sublemma[],
  structuredPayload: { provedStatement?: string; normalizedProof?: string },
  opts?: { userEdited?: boolean; derived?: boolean },
) => {
  const minors = history
    .filter((v) => v.baseMajor === baseMajor && v.type === 'structured')
    .map((v) => {
      const parts = (v.versionNumber || '').split('.');
      return parts.length > 1 ? parseInt(parts[1], 10) || 0 : 0;
    });
  const nextMinor = (minors.length ? Math.max(...minors) : 0) + 1;
  const versionNumber = `${baseMajor}.${nextMinor}`;
  return {
    id: uuid(),
    type: 'structured' as const,
    versionNumber,
    baseMajor,
    content: structuredPayload.normalizedProof || '',
    structured: structuredPayload,
    sublemmas: steps,
    userEdited: !!opts?.userEdited,
    derived: opts?.derived ?? true,
    timestamp: new Date(),
    validationResult: undefined,
    stepValidation: undefined,
    lastEditedStepIdx: null,
    graphData: undefined,
  } as ProofVersion;
};

// Autosave debounce timer (module-level so multiple components share it)
let rawAutosaveTimer: number | null = null;
let lastSavedRaw = '';

type StoreData = {
  view: View;
  problem: string | null;
  lastProblem: string | null;
  messages: Message[];

  // Explore mode
  exploreSeed: string | null;
  exploreMessages: Message[];
  exploreArtifacts: ExploreArtifacts | null;
  /**
   * User edits overlay for extracted artifacts.
   * Keyed by the original extracted string -> edited string.
   */
  exploreArtifactEdits: {
    candidateStatements: Record<string, string>;
    /**
     * Non-statement artifacts are scoped per candidate statement (keyed by the original statement string).
     */
    perStatement: Record<
      string,
      {
        assumptions: Record<string, string>;
        examples: Record<string, string>;
        counterexamples: Record<string, string>;
        openQuestions: Record<string, string>;
      }
    >;
  };
  exploreTurnId: number;
  cancelExploreCurrent?: (() => void) | null;

  loading: boolean;
  error: string | null;
  errorDetails: string | null;
  errorCode: string | null;
  isChatOpen: boolean;
  isHistoryOpen: boolean;
  viewMode: 'raw' | 'structured' | 'graph';
  proofHistory: ProofVersion[];

  // Raw proof + background decomposition state
  rawProof: string;
  attemptSummary: {
    status: 'PROVED_AS_IS' | 'PROVED_VARIANT' | 'FAILED';
    finalStatement: string | null;
    variantType: 'WEAKENING' | 'OPPOSITE' | null;
    explanation: string;
  } | null;
  isDecomposing: boolean;
  decomposeError: string | null;
  stepsReadyNonce: number;
  decomposeMeta: { provedStatement: string; normalizedProof: string } | null;
  /** The raw proof text that the latest decomposition corresponds to (used to know whether steps are up-to-date). */
  decomposedRaw: string | null;
  activeVersionIdx: number;
  pendingSuggestion: PendingSuggestion | null;
  pendingRejection: { explanation: string } | null;
  // Streaming progress
  progressLog: string[];
  // Cancel the current in-flight streaming request (if any)
  cancelCurrent?: (() => void) | null;
  // Live draft streaming (token-level)
  liveDraft: string;
  isDraftStreaming: boolean;
};

interface AppState extends StoreData {
  reset: () => void;

  // Explore navigation / state
  startExplore: (seed?: string) => void;
  setExploreMessages: (updater: ((prev: Message[]) => Message[]) | Message[]) => void;
  setExploreArtifacts: (artifacts: ExploreArtifacts | null) => void;
  setExploreArtifactEdit: (opts: {
    kind: 'candidateStatements' | 'assumptions' | 'examples' | 'counterexamples' | 'openQuestions';
    /** Candidate statement key for non-candidate edits. */
    statementKey?: string;
    original: string;
    edited: string;
  }) => void;
  clearExploreArtifactEdits: () => void;
  bumpExploreTurnId: () => number;
  getExploreTurnId: () => number;
  setExploreCancelCurrent: (cancel: (() => void) | null) => void;
  promoteToProof: (statement: string) => Promise<void>;
  startExploreFromFailedProof: () => void;

  startProof: (problem: string, opts?: { force?: boolean }) => Promise<void>;
  retry: () => Promise<void>;
  editProblem: () => void;
  setMessages: (updater: ((prev: Message[]) => Message[]) | Message[]) => void;

  // Variant handling
  acceptSuggestedChange: () => void;
  clearSuggestion: () => void;
  clearRejection: () => void;

  // UI actions
  setIsChatOpen: (open: boolean | ((prev: boolean) => boolean)) => void;
  setIsHistoryOpen: (open: boolean | ((prev: boolean) => boolean)) => void;
  setViewMode: (mode: 'raw' | 'structured' | 'graph') => void;
  toggleStructuredView: () => void;

  // Raw proof
  setRawProof: (raw: string) => void;
  runDecomposition: () => Promise<void>;

  // Version helpers (used by UI)
  getCurrentRawBaseMajor: () => number | null;
  hasUserEditedStructuredForBaseMajor: (baseMajor: number) => boolean;
  hasUserEditedStructuredForCurrentRaw: () => boolean;

  /** Snapshot a manual edit to a structured proof as a new structured minor version (N.k+1). */
  snapshotStructuredEdit: (updates: Partial<ProofVersion>) => void;

  // Proof version management
  setActiveVersionIndex: (index: number) => void;
  addProofVersion: (version: Omit<ProofVersion, 'timestamp'>) => void;
  updateCurrentProofVersion: (updates: Partial<ProofVersion>) => void;
  /**
   * Update non-versioned metadata for the currently active proof version.
   *
   * This is intended for ephemeral data like validation results and graph data.
   * It MUST NOT append a new proof version.
   */
  updateCurrentProofMeta: (updates: Partial<ProofVersion>) => void;
  updateCurrentStepValidation: (opts: {
    stepIndex: number;
    result?: ProofValidationResult;
  }) => void;
  clearLastEditedStep: () => void;

  /**
   * Delete a proof version by id.
   *
   * Deletion rules:
   * - Deleting a raw version deletes all versions for that baseMajor.
   * - Deleting a structured version deletes only that entry, unless it's the only
   *   structured version for that baseMajor (in which case we delete the entire group).
   */
  deleteProofVersion: (id: string) => void;

  // Navigation
  goBack: () => void;

  proof: () => ProofVersion;
}

let decomposeRunId = 0;

const initialState: StoreData = {
  view: 'home',
  problem: null,
  lastProblem: null,
  messages: [],

  exploreSeed: null,
  exploreMessages: [],
  exploreArtifacts: null,
  exploreArtifactEdits: {
    candidateStatements: {},
    perStatement: {},
  },
  exploreTurnId: 0,
  cancelExploreCurrent: null,

  loading: false,
  error: null,
  errorDetails: null,
  errorCode: null,
  // proof display UI defaults
  isChatOpen: false,
  isHistoryOpen: false,
  viewMode: 'raw',
  // proof review/history defaults
  proofHistory: [],

  // Raw proof + background decomposition state
  rawProof: '',
  attemptSummary: null,
  isDecomposing: false,
  decomposeError: null,
  stepsReadyNonce: 0,
  decomposeMeta: null,
  decomposedRaw: null,

  activeVersionIdx: 0,
  pendingSuggestion: null,
  pendingRejection: null,
  progressLog: [],
  cancelCurrent: null,
  liveDraft: '',
  isDraftStreaming: false,
};

export const useAppStore = create<AppState>((set, get) => ({
  ...initialState,

  startExplore: (seed?: string) => {
    // Cancel any in-flight explore stream
    const cancel = get().cancelExploreCurrent || null;
    if (cancel) {
      try { cancel(); } catch { }
    }

    const trimmed = seed?.trim() ? seed.trim() : null;

    // If a new seed is provided (coming from Home), start a fresh explore session.
    if (trimmed) {
      set({
        view: 'explore',
        exploreSeed: trimmed,
        exploreMessages: [],
        exploreArtifacts: null,
        exploreArtifactEdits: {
          candidateStatements: {},
          perStatement: {},
        },
        exploreTurnId: 0,
      });
      return;
    }

    // Otherwise, preserve any existing thread (direct revisit of /explore).
    set({
      view: 'explore',
      exploreSeed: get().exploreSeed,
      exploreMessages: get().exploreMessages.length ? get().exploreMessages : [],
      exploreArtifacts: get().exploreArtifacts,
    });
  },

  setExploreMessages: (updater) => {
    if (typeof updater === 'function') {
      set((state) => ({
        exploreMessages: (updater as (prev: Message[]) => Message[])(state.exploreMessages),
      }));
    } else {
      set({ exploreMessages: updater });
    }
  },

  setExploreArtifacts: (artifacts) => set({ exploreArtifacts: artifacts }),

  setExploreArtifactEdit: ({ kind, statementKey, original, edited }) => {
    const o = (original ?? '').trim();
    if (!o) return;
    const e = (edited ?? '').trim();

    if (kind === 'candidateStatements') {
      set((state) => ({
        exploreArtifactEdits: {
          ...state.exploreArtifactEdits,
          candidateStatements: {
            ...state.exploreArtifactEdits.candidateStatements,
            [o]: e,
          },
        },
      }));
      return;
    }

    const sk = (statementKey ?? '').trim();
    if (!sk) return;

    set((state) => {
      const prevForStmt = state.exploreArtifactEdits.perStatement[sk] ?? {
        assumptions: {},
        examples: {},
        counterexamples: {},
        openQuestions: {},
      };

      return {
        exploreArtifactEdits: {
          ...state.exploreArtifactEdits,
          perStatement: {
            ...state.exploreArtifactEdits.perStatement,
            [sk]: {
              ...prevForStmt,
              [kind]: {
                ...prevForStmt[kind],
                [o]: e,
              },
            },
          },
        },
      };
    });
  },

  clearExploreArtifactEdits: () =>
    set({
      exploreArtifactEdits: {
        candidateStatements: {},
        perStatement: {},
      },
    }),

  bumpExploreTurnId: () => {
    const next = get().exploreTurnId + 1;
    set({ exploreTurnId: next });
    return next;
  },

  getExploreTurnId: () => get().exploreTurnId,

  setExploreCancelCurrent: (cancel) => set({ cancelExploreCurrent: cancel }),

  promoteToProof: async (statement: string) => {
    const trimmed = statement.trim();
    if (!trimmed) return;
    // Keep explore context in store; switch view to proof via startProof
    await get().startProof(trimmed);
  },

  startExploreFromFailedProof: () => {
    const problem = (get().problem || '').trim();
    const original = (get().lastProblem || '').trim();
    const draft = (get().liveDraft || '').trim();

    const userContent = original || problem;
    const seededMessages: Message[] = [];

    if (userContent) {
      seededMessages.push({ role: 'user', content: userContent });
    }
    if (draft) {
      seededMessages.push({ role: 'assistant', content: draft });
    }

    set({
      view: 'explore',
      exploreSeed: userContent || null,
      exploreMessages: seededMessages,
      exploreArtifacts: null,
      exploreArtifactEdits: {
        candidateStatements: {},
        perStatement: {},
      },
      exploreTurnId: 0,
    });
  },

  startProof: async (problem: string, opts?: { force?: boolean }) => {
    const trimmed = problem.trim();
    if (!trimmed) return;

    // Initialize state for a new proof run
    // Cancel any in-flight decomposition runs by bumping the run id.
    decomposeRunId += 1;

    set({
      view: 'proof',
      problem: trimmed,
      lastProblem: trimmed,
      messages: [],
      loading: true,
      error: null,
      errorDetails: null,
      errorCode: null,

      // New split-phase proof state
      viewMode: 'raw',
      rawProof: '',
      attemptSummary: null,
      isDecomposing: false,
      decomposeError: null,
      stepsReadyNonce: 0,
      decomposeMeta: null,
      decomposedRaw: null,

      pendingSuggestion: null,
      pendingRejection: null,
      proofHistory: [],
      activeVersionIdx: 0,
      progressLog: ['Starting proof attempt...'],
      cancelCurrent: null,
      liveDraft: '',
      isDraftStreaming: false,
    });

    const appendLog = (line: string) => set((s) => ({ progressLog: [...s.progressLog, line] }));

    // Fallback non-streaming implementation (existing behavior)
    const runNonStreaming = async () => {
      await new Promise((r) => setTimeout(r, 50));
      const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] attemptProof(start, non-stream) len=', trimmed.length);
      const attempt = opts?.force
        ? await attemptProofActionForce(trimmed)
        : await attemptProofAction(trimmed);
      const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] attemptProof done ms=', t1 - t0, 'success=', (attempt as any)?.success);

      if (!attempt.success) {
        set({ loading: false, error: attempt.error || 'Failed to attempt proof.' });
        return;
      }

      if (attempt.status === 'FAILED') {
        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        set({
          loading: false,
          error: null,
          pendingRejection: { explanation: attempt.explanation || 'No details provided.' },
          proofHistory: [rawVersion],
          activeVersionIdx: 0,
        });
        return;
      }

      const d0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const decomp = await decomposeRawProofAction(attempt.rawProof || '');
      const d1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      console.debug('[UI][AppStore] decomposeRawProof done ms=', d1 - d0, 'success=', (decomp as any)?.success);

      if (!decomp.success) {
        // Decomposition is not fatal in the new split-phase UX.
        // Keep the proof UI alive (Raw Proof is still available) and surface a non-blocking error.
        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        set({
          loading: false,
          decomposeError: decomp.error || 'Failed to decompose the drafted proof.',
          proofHistory: [rawVersion],
          activeVersionIdx: 0,
        });
        return;
      }

      if (attempt.status === 'PROVED_AS_IS') {
        const steps: Sublemma[] = (decomp.sublemmas && decomp.sublemmas.length > 0)
          ? (decomp.sublemmas as Sublemma[])
          : ([{
            title: 'Proof',
            statement: decomp.provedStatement,
            proof: (decomp as any).normalizedProof || attempt.rawProof || 'Proof unavailable.',
          }] as Sublemma[]);
        console.debug('[UI][AppStore] provedAsIs steps', steps.length);
        const assistantMessage: Message = {
          role: 'assistant',
          content:
            `I've broken down the proof into the following steps:\n\n` +
            steps.map((s: Sublemma) => `**${s.title}:** ${s.statement}`).join('\n\n'),
        };

        const rawContent = attempt.rawProof || '';
        const rawVersion = makeRawVersion(get().proofHistory, rawContent);
        const structuredVersion = makeStructuredVersion(get().proofHistory, rawVersion.baseMajor, steps, {
          provedStatement: decomp.provedStatement,
          normalizedProof: (decomp as any).normalizedProof || '',
        }, { userEdited: false, derived: true });

        set({
          messages: [assistantMessage],
          loading: false,
          error: null,
          proofHistory: [rawVersion, structuredVersion],
          activeVersionIdx: 1,
          decomposedRaw: rawContent,
        });
        return;
      }

      // PROVED_VARIANT or similar: keep suggestion but ensure raw version exists
      const rawContent = attempt.rawProof || '';
      const rawVersion = makeRawVersion(get().proofHistory, rawContent);
      set({
        loading: false,
        error: null,
        pendingSuggestion: {
          suggested: attempt.finalStatement || (decomp as any).provedStatement,
          variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING',
          provedStatement: (decomp as any).provedStatement,
          sublemmas: (decomp as any).sublemmas as Sublemma[],
          explanation: attempt.explanation,
          normalizedProof: (decomp as any).normalizedProof,
          rawProof: attempt.rawProof || undefined,
        },
        proofHistory: [rawVersion],
        activeVersionIdx: 0,
      });
    };

    // Try token streaming first; fallback to metadata-only SSE, then non-streaming
    if (typeof window !== 'undefined' && 'EventSource' in window) {
      const runMetadataSSE = async () => {
        try {
          const url2 = `/api/proof/attempt-sse?problem=${encodeURIComponent(trimmed)}`;
          const es2 = new EventSource(url2);
          let finished2 = false;
          set({ cancelCurrent: () => { try { es2.close(); } catch { } } });

          es2.addEventListener('progress', (ev: MessageEvent) => {
            try {
              const data = JSON.parse(ev.data || '{}');
              if (data?.phase === 'attempt.start') appendLog('Attempting proof...');
              if (data?.phase === 'decompose.start') appendLog('Decomposing proof....');
            } catch { }
          });
          es2.addEventListener('attempt', (ev: MessageEvent) => {
            try {
              const data = JSON.parse(ev.data || '{}');
              if (data?.status === 'FAILED') {
                appendLog("Couldn't prove the statement as written. Showing explanation...");
              } else if (data?.status === 'PROVED_VARIANT') {
                appendLog('Proof generated for a revised statement....');
              } else {
                appendLog(`Model produced a proof (len ~${data?.rawProofLen ?? 0})...`);
              }
            } catch { }
          });
          es2.addEventListener('decompose', (ev: MessageEvent) => {
            try { const data = JSON.parse(ev.data || '{}'); appendLog(`Decomposed into ${data?.sublemmasCount ?? 0} step(s)....`); } catch { }
          });
          es2.addEventListener('server-error', (ev: MessageEvent) => {
            if (finished2) return; finished2 = true;
            try {
              const data = JSON.parse(ev.data || '{}');
              set({
                loading: false,
                error: data?.error || 'Unexpected server error.',
                errorDetails: data?.detail ?? null,
                errorCode: data?.code ?? null,
              });
            } catch {
              set({ loading: false, error: 'Unexpected server error.', errorDetails: null, errorCode: null });
            }
            try { es2.close(); } catch { }
            set({ cancelCurrent: null });
          });
          es2.addEventListener('done', (ev: MessageEvent) => {
            if (finished2) return; finished2 = true;
            try {
              const data = JSON.parse(ev.data || '{}');
              const attempt = data?.attempt; const decomp = data?.decompose;
              if (!attempt) { set({ loading: false, error: 'Malformed SSE response.' }); return; }
              if (attempt.status === 'FAILED') {
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({
                  loading: false,
                  error: null,
                  pendingRejection: { explanation: attempt.explanation || 'No details provided.' },
                  proofHistory: [rawVersion],
                  activeVersionIdx: 0,
                });
              } else if (!decomp) {
                // Decomposition failure is not fatal; allow the user to view/edit Raw Proof.
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({ loading: false, decomposeError: 'Failed to decompose the drafted proof.', proofHistory: [rawVersion], activeVersionIdx: 0 });
              } else if (attempt.status === 'PROVED_AS_IS') {
                const steps: Sublemma[] = (decomp.sublemmas && decomp.sublemmas.length > 0) ? (decomp.sublemmas as Sublemma[]) : ([{ title: 'Proof', statement: decomp.provedStatement, proof: (decomp as any).normalizedProof || attempt.rawProof || 'Proof unavailable.', }] as Sublemma[]);
                const assistantMessage: Message = { role: 'assistant', content: `I've broken down the proof into the following steps:\n\n` + steps.map((s: Sublemma) => `**${s.title}:** ${s.statement}`).join('\n\n'), };

                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                const structuredVersion = makeStructuredVersion(get().proofHistory, rawVersion.baseMajor, steps, { provedStatement: decomp.provedStatement, normalizedProof: (decomp as any).normalizedProof || '' }, { userEdited: false, derived: true });

                set({ messages: [assistantMessage], loading: false, error: null, proofHistory: [rawVersion, structuredVersion], activeVersionIdx: 1, decomposedRaw: attempt.rawProof || '' });
              } else {
                const rawVersion = makeRawVersion(get().proofHistory, attempt.rawProof || '');
                set({ loading: false, error: null, pendingSuggestion: { suggested: attempt.finalStatement || decomp.provedStatement, variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING', provedStatement: decomp.provedStatement, sublemmas: decomp.sublemmas as Sublemma[], explanation: attempt.explanation, normalizedProof: (decomp as any).normalizedProof, rawProof: attempt.rawProof || undefined, }, proofHistory: [rawVersion], activeVersionIdx: 0 });
              }
            } catch (e) { set({ loading: false, error: e instanceof Error ? e.message : 'Unexpected error.' }); }
            finally { try { es2.close(); } catch { } set({ cancelCurrent: null }); }
          });
          es2.onerror = () => { try { es2.close(); } catch { } set({ cancelCurrent: null }); appendLog('Metadata stream lost. Falling back to non-streaming...'); runNonStreaming(); };
        } catch { await runNonStreaming(); }
      };

      try {
        const url = `/api/proof/attempt-stream?problem=${encodeURIComponent(trimmed)}`;
        const es = new EventSource(url);
        let finished = false;
        let gotDelta = false;
        set({ cancelCurrent: () => { try { es.close(); } catch { } } });
        set({ isDraftStreaming: true, liveDraft: '' });

        es.addEventListener('model.start', (ev: MessageEvent) => {
          try { const data = JSON.parse(ev.data || '{}'); appendLog(`Using ${data?.provider}/${data?.model}...`); } catch { }
        });
        es.addEventListener('model.switch', (ev: MessageEvent) => {
          try { const d = JSON.parse(ev.data || '{}'); if (d?.to) appendLog(`Switched model to ${d.to}...`); } catch { }
        });
        es.addEventListener('model.delta', (ev: MessageEvent) => {
          try { const data = JSON.parse(ev.data || '{}'); const t = data?.text || ''; if (t) { if (!gotDelta) { appendLog('Receiving model output...'); gotDelta = true; } set((s) => ({ liveDraft: s.liveDraft + t })); } } catch { }
        });
        es.addEventListener('model.end', () => {
          // Draft complete, but we intentionally do NOT reveal it yet.
          // We first wait for classification (event: done) so we can show
          // PROVED_VARIANT suggestions *before* showing a tentative proof.
          set({ isDraftStreaming: false });
          appendLog('Proof draft completed....');
          appendLog('Classifying draft...');
        });
        es.addEventListener('classify.result', (ev: MessageEvent) => {
          try {
            const d = JSON.parse(ev.data || '{}');
            const st = d?.status;
            if (st === 'PROVED_VARIANT') {
              appendLog('Proof generated for a revised statement....');
            } else if (st === 'FAILED') {
              appendLog("Draft doesn't prove the statement as written. Showing explanation...");
            }
          } catch { }
        });

        // attempt-stream no longer performs decomposition server-side.
        // We do client-side decomposition only on explicit user request.

        es.addEventListener('server-error', (ev: MessageEvent) => {
          if (finished) return; finished = true;
          let friendly = 'Token stream failed.';
          let detail: string | null = null;
          let code: string | null = null;
          try {
            const data = JSON.parse(ev.data || '{}');
            if (data?.error) friendly = data.error; // already friendly from server
            if (data?.detail) detail = data.detail;
            if (data?.code) code = data.code;
          } catch { }
          try { es.close(); } catch { }
          set({ cancelCurrent: null, isDraftStreaming: false, errorDetails: detail, errorCode: code });
          appendLog(friendly + ' Falling back to metadata stream...');
          runMetadataSSE();
        });

        es.addEventListener('done', (ev: MessageEvent) => {
          if (finished) return; finished = true;
          try {
            const data = JSON.parse(ev.data || '{}');
            const attempt = data?.attempt;
            if (!attempt) {
              set({ loading: false, error: 'Malformed stream response.' });
              return;
            }

            // Cache classification outcome.
            set({
              attemptSummary: {
                status: attempt.status,
                finalStatement: attempt.finalStatement ?? null,
                variantType: attempt.variantType ?? null,
                explanation: attempt.explanation || '',
              },
            });

            // IMPORTANT UX RULE:
            // - If PROVED_VARIANT, show the suggestion FIRST and only show the tentative proof after Accept.
            // - Otherwise, reveal the tentative proof immediately.
            const raw = ((attempt.rawProof || get().liveDraft) ?? '').trim();

            if (attempt.status === 'PROVED_VARIANT') {
              const suggested = (attempt.finalStatement || '').trim();
              if (suggested) {
                set({
                  loading: false,
                  pendingSuggestion: {
                    suggested,
                    variantType: (attempt.variantType as 'WEAKENING' | 'OPPOSITE') || 'WEAKENING',
                    provedStatement: suggested,
                    sublemmas: [],
                    explanation: attempt.explanation || '',
                    rawProof: raw || undefined,
                    normalizedProof: undefined,
                  },
                });
              } else {
                // Fallback: no suggested statement; just show the draft.
                const rawVersion = makeRawVersion(get().proofHistory, raw);
                set((state) => ({
                  loading: false,
                  viewMode: 'raw',
                  rawProof: raw,
                  decomposeError: null,
                  isDecomposing: false,
                  proofHistory: [...state.proofHistory, rawVersion],
                  activeVersionIdx: state.proofHistory.length,
                }));
                lastSavedRaw = raw;
              }
              return;
            }

            // Reveal raw proof for PROVED_AS_IS and FAILED.
            if (raw.length > 0) {
              const rawVersion = makeRawVersion(get().proofHistory, raw);
              set((state) => ({
                loading: false,
                viewMode: 'raw',
                rawProof: raw,
                decomposeError: null,
                isDecomposing: false,
                proofHistory: [...state.proofHistory, rawVersion],
                activeVersionIdx: state.proofHistory.length,
                pendingRejection:
                  attempt.status === 'FAILED'
                    ? { explanation: attempt.explanation || 'No details provided.' }
                    : null,
              }));
              lastSavedRaw = raw;
            } else {
              set({
                loading: false,
                pendingRejection:
                  attempt.status === 'FAILED'
                    ? { explanation: attempt.explanation || 'No details provided.' }
                    : null,
              });
            }
          } catch (e) {
            set({ loading: false, error: e instanceof Error ? e.message : 'Unexpected error.' });
          } finally {
            try { es.close(); } catch { }
            set({ cancelCurrent: null, isDraftStreaming: false });
          }
        });

        es.onerror = () => {
          if (finished) return; finished = true; try { es.close(); } catch { }
          set({ cancelCurrent: null, isDraftStreaming: false });
          appendLog('Token stream connection lost. Falling back to metadata stream...');
          runMetadataSSE();
        };
      } catch (e) {
        appendLog('Token streaming not available. Falling back to metadata stream...');
        await runMetadataSSE();
      }
    } else {
      await runNonStreaming();
    }
  },

  setMessages: (updater) => {
    if (typeof updater === 'function') {
      set((state) => ({
        messages: (updater as (prev: Message[]) => Message[])(state.messages),
      }));
    } else {
      set({ messages: updater });
    }
  },

  reset: () => {
    const cancel = get().cancelCurrent || null;
    if (cancel) {
      try { cancel(); } catch { }
    }
    const cancelExplore = get().cancelExploreCurrent || null;
    if (cancelExplore) {
      try { cancelExplore(); } catch { }
    }
    set((state) => ({ ...initialState, lastProblem: state.lastProblem }));
  },

  // Additional actions
  retry: async () => {
    const p = get().lastProblem;
    if (p) {
      await get().startProof(p, { force: true });
    }
  },
  editProblem: () => {
    set((state) => ({
      ...state,
      view: 'home',
      loading: false,
      error: null,
      errorDetails: null,
      errorCode: null,
      pendingSuggestion: null,
    }));
  },

  // UI actions
  setIsChatOpen: (open) => {
    if (typeof open === 'function') {
      set((state) => ({
        isChatOpen: open(state.isChatOpen),
      }));
    } else {
      set({ isChatOpen: open });
    }
  },
  setIsHistoryOpen: (open) => {
    if (typeof open === 'function') {
      set((state) => ({
        isHistoryOpen: open(state.isHistoryOpen),
      }));
    } else {
      set({ isHistoryOpen: open });
    }
  },
  setViewMode: (mode) =>
    set((state) => {
      if (state.viewMode === mode) return state;

      const current = state.proofHistory[state.activeVersionIdx];
      const baseMajor = current?.baseMajor;

      const pickLast = (predicate: (v: ProofVersion) => boolean): number | null => {
        for (let i = state.proofHistory.length - 1; i >= 0; i--) {
          if (predicate(state.proofHistory[i])) return i;
        }
        return null;
      };

      let nextIdx = state.activeVersionIdx;
      if (mode === 'structured') {
        nextIdx =
          (baseMajor != null
            ? pickLast((v) => v.type === 'structured' && v.baseMajor === baseMajor)
            : null) ?? pickLast((v) => v.type === 'structured') ?? state.activeVersionIdx;
      } else if (mode === 'raw') {
        nextIdx =
          (baseMajor != null ? pickLast((v) => v.type === 'raw' && v.baseMajor === baseMajor) : null) ??
          pickLast((v) => v.type === 'raw') ??
          state.activeVersionIdx;
      }

      const next = state.proofHistory[nextIdx];
      return {
        viewMode: mode,
        activeVersionIdx: nextIdx,
        rawProof: mode === 'raw' ? (next?.content ?? state.rawProof) : state.rawProof,
      };
    }),
  toggleStructuredView: () =>
    set((state) => ({ viewMode: state.viewMode === 'structured' ? 'raw' : 'structured' })),

  setRawProof: (raw) => {
    const next = raw ?? '';

    // Update editor state only. Do NOT mutate existing history entries.
    set((state) => {
      const cur = state.rawProof;
      if (cur === next) return state;
      const trimmedNext = (next || '').trim();
      const trimmedDecomposed = (state.decomposedRaw || '').trim();
      const decompositionIsStale = !!trimmedDecomposed && trimmedNext !== trimmedDecomposed;
      return {
        rawProof: next,
        decomposeError: null,
        decomposeMeta: null,
        decomposedRaw: decompositionIsStale ? null : state.decomposedRaw,
        pendingSuggestion: null,
      };
    });

    // Debounced autosave: append a new raw major version after 3s idle if content changed.
    // This guarantees every saved raw edit becomes a new history entry.
    try {
      if (typeof window !== 'undefined') {
        if (rawAutosaveTimer) window.clearTimeout(rawAutosaveTimer);
        rawAutosaveTimer = window.setTimeout(() => {
          const cur = (get().rawProof || '').trim();
          if (!cur) return;
          if (cur === lastSavedRaw) return;

          const history = get().proofHistory;

          // compute next raw major
          const maxMajor = history.reduce(
            (m, v) => (v.type === 'raw' ? Math.max(m, v.baseMajor) : m),
            0,
          );
          const nextMajor = (maxMajor || 0) + 1;

          get().addProofVersion({
            id: uuid(),
            type: 'raw',
            versionNumber: `${nextMajor}`,
            baseMajor: nextMajor,
            content: cur,
            sublemmas: [],
            userEdited: true,
            derived: false,
            graphData: undefined,
            validationResult: undefined,
            stepValidation: undefined,
            lastEditedStepIdx: null,
          } as any);

          lastSavedRaw = cur;
        }, 3000);
      }
    } catch {
      /* ignore timers in SSR */
    }

    // Note: decomposition is automatic for the initial AI draft (Phase B),
    // but we do NOT automatically decompose on every raw edit.
  },

  runDecomposition: async () => {
    const raw = (get().rawProof || '').trim();
    if (raw.length < 10) return;

    const myRun = ++decomposeRunId;
    set({ isDecomposing: true, decomposeError: null });

    try {
      const result = await decomposeRawProofAction(raw);
      if (decomposeRunId !== myRun) return;

      if (!result.success) {
        set({ isDecomposing: false, decomposeError: result.error || 'Failed to decompose proof.' });
        return;
      }

      const steps: Sublemma[] =
        (result.sublemmas && result.sublemmas.length > 0)
          ? (result.sublemmas as Sublemma[])
          : ([{
            title: 'Proof',
            statement: result.provedStatement,
            proof: (result as any).normalizedProof || raw || 'Proof unavailable.',
          }] as Sublemma[]);

      // Update decompose meta (used for toasts / context).
      // IMPORTANT: do NOT mutate existing versions here. Decomposition results are persisted
      // only by appending a new structured ProofVersion below.
      set((state) => ({
        isDecomposing: false,
        decomposeError: null,
        decomposeMeta: {
          provedStatement: result.provedStatement,
          normalizedProof: (result as any).normalizedProof || '',
        },
        decomposedRaw: raw,
        stepsReadyNonce: state.stepsReadyNonce + 1,
      }));

      // Create a new structured version.
      const history = get().proofHistory;

      // Determine which raw major this structured version should attach to.
      // Priority:
      // 1) If the currently active version is a raw entry, attach to its baseMajor (user restored a prior raw).
      // 2) Else if rawProof matches a saved raw entry, attach to that baseMajor.
      // 3) Else fall back to latest raw major.
      const active = get().proof();
      const baseMajor =
        (active?.type === 'raw' ? active.baseMajor : null) ??
        get().getCurrentRawBaseMajor() ??
        (getMaxRawMajor(history) || 0);

      const structuredVersion = makeStructuredVersion(
        history,
        baseMajor || 1,
        steps,
        {
          provedStatement: result.provedStatement,
          normalizedProof: (result as any).normalizedProof || '',
        },
        { userEdited: false, derived: true },
      );

      // Append a new structured version.
      // IMPORTANT: keep the user's currently selected version stable (this often runs in the background).
      set((state) => {
        const nextIdx = state.proofHistory.length;
        const shouldActivate = state.viewMode === 'structured';
        return {
          proofHistory: [...state.proofHistory, { ...structuredVersion, timestamp: new Date() } as any],
          activeVersionIdx: shouldActivate ? nextIdx : state.activeVersionIdx,
        };
      });
    } catch (e: any) {
      if (decomposeRunId !== myRun) return;
      set({ isDecomposing: false, decomposeError: e?.message || 'Failed to decompose proof.' });
    }
  },


  getCurrentRawBaseMajor: () => {
    const raw = (get().rawProof || '').trim();
    if (!raw) return null;
    const history = get().proofHistory;
    // Prefer exact content match, else fall back to max raw major.
    const exact = history
      .filter((v) => v.type === 'raw' && (v.content || '').trim() === raw)
      .map((v) => v.baseMajor);
    if (exact.length) return Math.max(...exact);
    const max = history.filter((v) => v.type === 'raw').map((v) => v.baseMajor);
    return max.length ? Math.max(...max) : null;
  },

  hasUserEditedStructuredForBaseMajor: (baseMajor: number) => {
    const history = get().proofHistory;
    return history.some(
      (v) => v.type === 'structured' && v.baseMajor === baseMajor && v.userEdited,
    );
  },

  hasUserEditedStructuredForCurrentRaw: () => {
    const base = get().getCurrentRawBaseMajor();
    if (!base) return false;
    return get().hasUserEditedStructuredForBaseMajor(base);
  },

  snapshotStructuredEdit: (updates) => {
    const cur = get().proof();
    if (!cur || cur.type !== 'structured') {
      // Not in structured mode; fall back to updating current.
      get().updateCurrentProofVersion({ ...updates, userEdited: true });
      return;
    }

    const history = get().proofHistory;
    const baseMajor = cur.baseMajor;

    const next = makeStructuredVersion(
      history,
      baseMajor,
      (updates.sublemmas as Sublemma[]) ?? cur.sublemmas,
      {
        provedStatement: updates.structured?.provedStatement ?? cur.structured?.provedStatement,
        normalizedProof: updates.structured?.normalizedProof ?? cur.structured?.normalizedProof,
      },
      { userEdited: true, derived: false },
    );

    // Carry over other fields from the current version unless overridden.
    get().addProofVersion({
      ...next,
      // Allow callers to override a subset
      ...updates,
      id: next.id,
      type: 'structured',
      baseMajor,
      versionNumber: next.versionNumber,
      userEdited: true,
      derived: false,
      sublemmas: (updates.sublemmas as Sublemma[]) ?? next.sublemmas,
      structured: {
        provedStatement: next.structured?.provedStatement,
        normalizedProof: next.structured?.normalizedProof,
        ...(updates.structured || {}),
      },
      content:
        updates.content ??
        next.structured?.normalizedProof ??
        (typeof cur.content === 'string' ? cur.content : ''),
      validationResult: updates.validationResult ?? undefined,
      stepValidation: updates.stepValidation,
      lastEditedStepIdx: updates.lastEditedStepIdx ?? null,
      graphData: updates.graphData,
    } as any);

    set({ viewMode: 'structured' });
  },

  acceptSuggestedChange: () => {
    const s = get().pendingSuggestion;
    if (!s) return;

    // When the suggestion is accepted, we reveal the tentative proof.
    // In streaming mode we might not have decomposed steps yet.
    const rawContent = (s.rawProof || '').trim();
    const provedStatement = (s.provedStatement || s.suggested || '').trim();

    // Ensure a raw version exists in history for this content (avoid bumping majors unnecessarily).
    const curHistory = get().proofHistory;
    let rawIdx = curHistory.findIndex(
      (v) => v.type === 'raw' && (v.content || '').trim() === rawContent,
    );

    let nextHistory = curHistory;
    let rawVersion: ProofVersion | null = rawIdx >= 0 ? curHistory[rawIdx] : null;

    if (!rawVersion) {
      rawVersion = makeRawVersion(curHistory, rawContent);
      nextHistory = [...curHistory, rawVersion];
      rawIdx = nextHistory.length - 1;
    }

    lastSavedRaw = rawContent;

    // Commit the accepted statement and reveal raw proof.
    // Important: only create a structured version immediately if we already have decomposed steps.
    // Otherwise, kick off background decomposition so Structured Proof gets real sublemmas.
    const hasSteps = Array.isArray(s.sublemmas) && s.sublemmas.length > 0;

    if (hasSteps) {
      const steps = s.sublemmas as Sublemma[];
      const structuredVersion = makeStructuredVersion(
        nextHistory,
        rawVersion.baseMajor,
        steps,
        {
          provedStatement,
          normalizedProof: s.normalizedProof || '',
        },
        { userEdited: false, derived: true },
      );

      set({
        problem: provedStatement,
        pendingSuggestion: null,
        viewMode: 'raw',
        rawProof: rawContent,
        proofHistory: [...nextHistory, structuredVersion],
        activeVersionIdx: rawIdx,
        decomposedRaw: rawContent,
        messages: [
          {
            role: 'assistant',
            content:
              `I've broken down the proof into the following steps:\n\n` +
              steps.map((x) => `**${x.title}:** ${x.statement}`).join('\n\n'),
          } as Message,
        ],
      });

      return;
    }

    // No steps available yet (streaming path): switch to raw immediately and decompose in background.
    set({
      problem: provedStatement,
      pendingSuggestion: null,
      viewMode: 'raw',
      rawProof: rawContent,
      proofHistory: nextHistory,
      activeVersionIdx: rawIdx,
      decomposedRaw: null,
      decomposeMeta: null,
      decomposeError: null,
      messages: [],
    });

    // Fire-and-forget: generates a proper structured version once ready.
    void get().runDecomposition();
  },

  clearSuggestion: () => set({ pendingSuggestion: null }),
  clearRejection: () => set({ pendingRejection: null }),

  // Go back to previous proof version (if any) and ensure steps view
  goBack: () =>
    set((state) => {
      const nextIdx = Math.max(0, state.activeVersionIdx - 1);
      return {
        activeVersionIdx: nextIdx,
        viewMode: 'structured',
      };
    }),

  /**
   * Restore a specific proof history entry.
   *
   * Important: selecting a version must also reconcile `viewMode` and `rawProof`
   * to avoid UI states like "Structured proof" with no steps when a raw version is active.
   */
  setActiveVersionIndex: (index) =>
    set((state) => {
      const nextIdx = Math.max(0, Math.min(index, state.proofHistory.length - 1));
      const next = state.proofHistory[nextIdx];
      if (!next) return state;

      // Default: switch to a sensible mode for the restored version type.
      // If we're currently in Graph view, keep Graph view while switching versions.
      // (Graph should render for whichever structured version is active.)
      const nextViewMode: StoreData['viewMode'] =
        state.viewMode === 'graph' ? 'graph' : next.type === 'raw' ? 'raw' : 'structured';

      // Ensure rawProof reflects the restored raw version.
      const nextRawProof = next.type === 'raw' ? (next.content ?? '') : state.rawProof;

      return {
        ...state,
        activeVersionIdx: nextIdx,
        viewMode: nextViewMode,
        rawProof: nextRawProof,
      };
    }),

  addProofVersion: (version) =>
    set((state) => ({
      proofHistory: [...state.proofHistory, { ...version, timestamp: new Date() }],
      activeVersionIdx: state.proofHistory.length,
    })),

  updateCurrentProofMeta: (updates) =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, ...updates } : version,
      ),
    })),

  updateCurrentProofVersion: (updates) => {
    const cur = get().proofHistory[get().activeVersionIdx];
    if (!cur) return;

    // For raw/structured edits that should be "saved", we append a new version instead of mutating.
    // (Callers can still use updateCurrentProofVersion for truly ephemeral updates, but we prefer new versions.)
    if (cur.type === 'raw') {
      get().addProofVersion({
        ...cur,
        ...updates,
        id: uuid(),
        type: 'raw',
        // Raw edits always bump the major.
        versionNumber: `${(getMaxRawMajor(get().proofHistory) || 0) + 1}`,
        baseMajor: (getMaxRawMajor(get().proofHistory) || 0) + 1,
        content: typeof updates.content === 'string' ? updates.content : cur.content,
        userEdited: true,
        derived: false,
        sublemmas: [],
        graphData: undefined,
        validationResult: undefined,
        stepValidation: undefined,
        lastEditedStepIdx: null,
      } as any);
      lastSavedRaw = (typeof updates.content === 'string' ? updates.content : cur.content) || '';
      return;
    }

    if (cur.type === 'structured') {
      // Re-route to the existing structured snapshot helper.
      get().snapshotStructuredEdit(updates);
      return;
    }

    // Fallback: mutate (should be rare)
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, ...updates } : version,
      ),
    }));
  },

  updateCurrentStepValidation: ({ stepIndex, result }) =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) => {
        if (idx !== state.activeVersionIdx) return version;
        const next = { ...version };
        const prev = next.stepValidation || {};
        if (result) {
          next.stepValidation = { ...prev, [stepIndex]: result };
        } else {
          const { [stepIndex]: _omit, ...rest } = prev;
          next.stepValidation = rest;
        }
        return next;
      }),
    })),

  clearLastEditedStep: () =>
    set((state) => ({
      proofHistory: state.proofHistory.map((version, idx) =>
        idx === state.activeVersionIdx ? { ...version, lastEditedStepIdx: null } : version,
      ),
    })),

  deleteProofVersion: (id: string) =>
    set((state) => {
      const history = state.proofHistory;
      const idx = history.findIndex((v) => v.id === id);
      if (idx < 0) return state;

      const target = history[idx];
      const baseMajor = target.baseMajor;

      // Determine deletion set.
      const structuredForMajor = history.filter(
        (v) => v.baseMajor === baseMajor && v.type === 'structured',
      );

      const deleteWholeGroup =
        target.type === 'raw' ||
        (target.type === 'structured' && structuredForMajor.length <= 1);

      const nextHistory = deleteWholeGroup
        ? history.filter((v) => v.baseMajor !== baseMajor)
        : history.filter((v) => v.id !== id);

      // If nothing left, reset proof-specific state to a safe empty.
      if (nextHistory.length === 0) {
        return {
          ...state,
          proofHistory: [],
          activeVersionIdx: 0,
          viewMode: 'raw',
          rawProof: '',
          decomposedRaw: null,
          decomposeMeta: null,
        };
      }

      // Pick next active index.
      // Prefer staying on the same numeric index; if we deleted something before it, shift left.
      let nextActive = state.activeVersionIdx;

      if (idx < state.activeVersionIdx) {
        nextActive = Math.max(0, state.activeVersionIdx - 1);
      }

      // If we deleted the active item (or group), clamp to nearest valid entry.
      nextActive = Math.max(0, Math.min(nextActive, nextHistory.length - 1));

      const next = nextHistory[nextActive];

      // Ensure viewMode makes sense.
      let nextViewMode: StoreData['viewMode'] = state.viewMode;
      if (nextViewMode !== 'graph') {
        nextViewMode = next.type === 'raw' ? 'raw' : 'structured';
      } else {
        // Graph mode requires structured; if we ended up on raw, fall back.
        if (next.type === 'raw') nextViewMode = 'raw';
      }

      // Keep rawProof in sync if we are on a raw version.
      const nextRawProof = next.type === 'raw' ? (next.content ?? '') : state.rawProof;

      // If we deleted the only structured for the currently decomposed raw, clear decomposition pointers.
      // (Prevents UI thinking "steps are ready" when no structured versions remain for that major.)
      const stillHasStructuredForMajor = nextHistory.some(
        (v) => v.baseMajor === baseMajor && v.type === 'structured',
      );

      const shouldClearDecomposition =
        deleteWholeGroup ||
        (target.type === 'structured' && !stillHasStructuredForMajor);

      return {
        ...state,
        proofHistory: nextHistory,
        activeVersionIdx: nextActive,
        viewMode: nextViewMode,
        rawProof: nextRawProof,
        decomposedRaw: shouldClearDecomposition ? null : state.decomposedRaw,
        decomposeMeta: shouldClearDecomposition ? null : state.decomposeMeta,
      };
    }),

  proof: () => get().proofHistory[get().activeVersionIdx],
}));
