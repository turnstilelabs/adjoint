diff --git a/src/ai/flows/generate-proof-graph.ts b/src/ai/flows/generate-proof-graph.ts
index bd09546..72f3aba 100644
--- a/src/ai/flows/generate-proof-graph.ts
+++ b/src/ai/flows/generate-proof-graph.ts
@@ -51,7 +51,7 @@ const generateProofGraphPrompt = ai.definePrompt({
 1.  Create a node for each sublemma. Use "step-N" as the node ID, where N is the 1-based index of the sublemma in the input array. The node's label should be the sublemma's title.
 2.  Analyze the dependencies between the sublemmas. An edge should exist from node A to node B if sublemma B directly depends on the result or statement of sublemma A.
 3.  The graph should represent the logical flow. Sometimes this will be a simple linear chain (1 -> 2 -> 3), but other times a step might depend on multiple previous steps.
-4.  Create edges connecting the nodes based on these dependencies. Use "edge-S-T" as the edge ID, where S is the source step number and T is the target step number (1-based).
+4.  Create DIRECTED edges connecting the nodes based on these dependencies. Edges MUST be oriented from dependency to dependent: set "source" to the step that is used (A) and "target" to the step that depends on it (B). Use "edge-S-T" as the edge ID, where S is the source step number and T is the target step number (1-based). Do not output undirected edges.
 
 **Proof Steps to Analyze:**
 {{#each proofSteps}}
diff --git a/src/app/globals.css b/src/app/globals.css
index 05d3dc2..5ed4ed3 100644
--- a/src/app/globals.css
+++ b/src/app/globals.css
@@ -3,7 +3,6 @@
 @tailwind utilities;
 
 /* KaTeX styles to hide MathML fallback and style rendered math */
-@import 'katex/dist/katex.min.css';
 
 @layer base {
   :root {
diff --git a/src/components/proof-display.tsx b/src/components/proof-display.tsx
index 56bbd3a..86fd1ac 100644
--- a/src/components/proof-display.tsx
+++ b/src/components/proof-display.tsx
@@ -61,7 +61,15 @@ export default function ProofDisplay({
     startGraphLoadingTransition(async () => {
       const result = await generateProofGraphAction(steps);
       if ('nodes' in result && 'edges' in result) {
-        setGraphData({ nodes: result.nodes, edges: result.edges });
+        setGraphData({
+          nodes: result.nodes.map(n => {
+            const m = n.id.match(/step-(\d+)/);
+            const idx = m ? parseInt(m[1], 10) - 1 : -1;
+            const content = idx >= 0 && idx < steps.length ? steps[idx].content : '';
+            return { ...n, content };
+          }),
+          edges: result.edges
+        });
       } else {
         setGraphData(null);
         toast({
@@ -107,8 +115,18 @@ export default function ProofDisplay({
           );
           return { ...prev, nodes: updatedNodes };
         });
+      } else if (opts?.change === 'content' && typeof opts.changedIndex === 'number') {
+        const changedIndex = opts.changedIndex;
+        setGraphData(prev => {
+          if (!prev) return prev;
+          const nodeId = `step-${changedIndex + 1}`;
+          const updatedNodes = prev.nodes.map(n =>
+            n.id === nodeId ? { ...n, content: newSublemmas[changedIndex].content } : n
+          );
+          return { ...prev, nodes: updatedNodes };
+        });
       }
-      // For content-only edits, leave graph structure as-is
+      // For other edits, leave graph structure as-is
     } else {
       setGraphData(null); // Invalidate old graph data
       generateGraph(newSublemmas);
diff --git a/src/components/proof-graph.tsx b/src/components/proof-graph.tsx
index c2c0c1e..e3f2df6 100644
--- a/src/components/proof-graph.tsx
+++ b/src/components/proof-graph.tsx
@@ -1,19 +1,18 @@
 'use client';
-import { useMemo } from 'react';
-import ReactFlow, {
-  MiniMap,
-  Controls,
-  Background,
-  type Node,
-  type Edge,
-  ReactFlowProvider,
-} from 'reactflow';
-import 'reactflow/dist/style.css';
+
+import React, { useEffect, useMemo, useRef, useState } from 'react';
 import { Card } from './ui/card';
-import { DagreLayout } from './dagre-layout';
+import {
+  Tooltip,
+  TooltipContent,
+  TooltipProvider,
+  TooltipTrigger,
+} from './ui/tooltip';
+import { Dialog, DialogContent, DialogHeader, DialogTitle } from './ui/dialog';
+import { KatexRenderer } from './katex-renderer';
 
 export type GraphData = {
-  nodes: { id: string; label: string }[];
+  nodes: { id: string; label: string; content?: string }[];
   edges: { id: string; source: string; target: string }[];
 };
 
@@ -21,60 +20,578 @@ interface ProofGraphProps {
   graphData: GraphData;
 }
 
-const nodeDefaults = {
-  sourcePosition: 'bottom',
-  targetPosition: 'top',
-  style: {
-    borderRadius: '0.5rem',
-    border: '1px solid hsl(var(--border))',
-    background: 'hsl(var(--card))',
-    color: 'hsl(var(--card-foreground))',
-    boxShadow: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
-  },
+type PositionedNode = {
+  id: string;
+  label: string;
+  x: number;
+  y: number;
+  width: number;
+  height: number;
+  lines: string[];
+  content?: string;
 };
 
-export function ProofGraph({ graphData }: ProofGraphProps) {
-  if (!graphData || !graphData.nodes || !graphData.edges) {
-    return <div className="text-center p-8">No graph data available.</div>;
+type DrawEdge = {
+  id: string;
+  sourceId: string;
+  targetId: string;
+  source: { x: number; y: number };
+  target: { x: number; y: number };
+};
+
+type DraggingState = {
+  nodeId: string;
+  offsetX: number;
+  offsetY: number;
+  startX: number;
+  startY: number;
+};
+
+const SVG_WIDTH = 800;
+const SVG_HEIGHT = 600;
+const NODE_DIM = { width: 260, height: 96, rx: 10 };
+const HEADER_H = 24;
+
+const ARROW_OFFSET = 8; // push arrowhead slightly outside target rect
+
+function borderPointRect(
+  cx: number,
+  cy: number,
+  towardX: number,
+  towardY: number,
+  halfW: number,
+  halfH: number
+) {
+  const dx = towardX - cx;
+  const dy = towardY - cy;
+  if (dx === 0 && dy === 0) return { x: cx, y: cy };
+  const absDx = Math.abs(dx);
+  const absDy = Math.abs(dy);
+  const scale = Math.min(halfW / (absDx || 1e-6), halfH / (absDy || 1e-6));
+  return { x: cx + dx * scale, y: cy + dy * scale };
+}
+
+function offsetPoint(x: number, y: number, fromX: number, fromY: number, distance: number) {
+  const vx = x - fromX;
+  const vy = y - fromY;
+  const len = Math.hypot(vx, vy) || 1;
+  return { x: x + (vx / len) * distance, y: y + (vy / len) * distance };
+}
+
+function computeEdgeEndpoints(
+  sx: number,
+  sy: number,
+  sHalfW: number,
+  sHalfH: number,
+  tx: number,
+  ty: number,
+  tHalfW: number,
+  tHalfH: number
+) {
+  const sourceBorder = borderPointRect(sx, sy, tx, ty, sHalfW, sHalfH);
+  const targetBorder = borderPointRect(tx, ty, sx, sy, tHalfW, tHalfH);
+  // move a bit outside nodes to ensure visibility above node rect
+  const sourceOutside = offsetPoint(sourceBorder.x, sourceBorder.y, sx, sy, 2);
+  const targetOutside = offsetPoint(targetBorder.x, targetBorder.y, sx, sy, ARROW_OFFSET);
+  return {
+    source: { x: sourceOutside.x, y: sourceOutside.y },
+    target: { x: targetOutside.x, y: targetOutside.y },
+  };
+}
+
+// Deterministic initial positions (circular layout) to avoid jumping on re-render
+function initialPosition(index: number, total: number) {
+  const cx = SVG_WIDTH / 2;
+  const cy = SVG_HEIGHT / 2;
+  const radius = Math.min(SVG_WIDTH, SVG_HEIGHT) * 0.32;
+  const angle = (2 * Math.PI * index) / Math.max(1, total);
+  const x = cx + radius * Math.cos(angle);
+  const y = cy + radius * Math.sin(angle);
+  return { x, y };
+}
+
+/** Text measurement helpers to adapt node size to title */
+const TITLE_MIN_WIDTH = 160;
+const TITLE_MAX_WIDTH = 360;
+const TITLE_PADDING_X = 16;
+const TITLE_PADDING_Y = 10;
+const TITLE_FONT = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
+const TITLE_LINE_HEIGHT = 18;
+
+let _measureCtx: CanvasRenderingContext2D | null = null;
+function getMeasureCtx() {
+  if (_measureCtx) return _measureCtx;
+  const canvas = document.createElement('canvas');
+  _measureCtx = canvas.getContext('2d');
+  if (_measureCtx) _measureCtx.font = TITLE_FONT;
+  return _measureCtx;
+}
+
+function measureTitle(label: string) {
+  const ctx = getMeasureCtx();
+  if (!ctx) {
+    const fallbackW = Math.min(TITLE_MAX_WIDTH, Math.max(TITLE_MIN_WIDTH, label.length * 7 + TITLE_PADDING_X * 2));
+    const lineCount = Math.ceil(fallbackW / (TITLE_MAX_WIDTH - TITLE_PADDING_X * 2));
+    const h = HEADER_H + TITLE_PADDING_Y * 2 + Math.max(1, lineCount) * TITLE_LINE_HEIGHT;
+    return { width: fallbackW, height: h, lines: [label] };
+  }
+  ctx.font = TITLE_FONT;
+  const words = label.split(/\s+/);
+  const lines: string[] = [];
+  let current = '';
+  const maxTextWidth = TITLE_MAX_WIDTH - TITLE_PADDING_X * 2;
+
+  for (const w of words) {
+    const test = current ? current + ' ' + w : w;
+    const testWidth = ctx.measureText(test).width;
+    if (testWidth <= maxTextWidth) {
+      current = test;
+    } else {
+      if (current) lines.push(current);
+      current = w;
+    }
   }
+  if (current) lines.push(current);
+
+  const textWidth = Math.min(
+    TITLE_MAX_WIDTH,
+    Math.max(
+      TITLE_MIN_WIDTH,
+      Math.max(...lines.map(line => ctx.measureText(line).width), 0) + TITLE_PADDING_X * 2
+    )
+  );
+  const height = HEADER_H + TITLE_PADDING_Y * 2 + Math.max(1, lines.length) * TITLE_LINE_HEIGHT;
+  return { width: textWidth, height, lines };
+}
+
+export function ProofGraph({ graphData }: ProofGraphProps) {
+  const svgRef = useRef<SVGSVGElement>(null);
+
+  const [nodes, setNodes] = useState<PositionedNode[]>([]);
+  const [edges, setEdges] = useState<DrawEdge[]>([]);
+  const [hoveredNode, setHoveredNode] = useState<string | null>(null);
+  const [dragging, setDragging] = useState<DraggingState | null>(null);
+  const movedRef = useRef(false);
+  const [open, setOpen] = useState(false);
+  const [selectedNode, setSelectedNode] = useState<PositionedNode | null>(null);
+
+  // Reconcile nodes when graphData changes:
+  // - keep positions for existing nodes
+  // - add positions for new nodes deterministically
+  // - update labels when they change
+  useEffect(() => {
+    if (!graphData?.nodes) {
+      setNodes([]);
+      return;
+    }
+
+    const prevById = new Map(nodes.map((n) => [n.id, n]));
+    const nextNodes: PositionedNode[] = graphData.nodes.map((n, idx) => {
+      const dims = measureTitle(n.label);
+      const prev = prevById.get(n.id);
+      if (prev) {
+        // update label/content and recalc size, keep position
+        return {
+          ...prev,
+          label: n.label,
+          content: (n as any).content ?? prev.content,
+          width: dims.width,
+          height: dims.height,
+          lines: dims.lines,
+        };
+      }
+      // new node: place deterministically with measured size
+      const pos = initialPosition(idx, graphData.nodes.length);
+      return {
+        id: n.id,
+        label: n.label,
+        x: pos.x,
+        y: pos.y,
+        width: dims.width,
+        height: dims.height,
+        lines: dims.lines,
+        content: (n as any).content,
+      };
+    });
+
+    setNodes(nextNodes);
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [graphData?.nodes]);
+
+  // Recompute edges when nodes or graphData.edges change
+  useEffect(() => {
+    if (!graphData?.edges || nodes.length === 0) {
+      setEdges([]);
+      return;
+    }
+    const byId = new Map(nodes.map((n) => [n.id, n]));
+    const nextEdges: DrawEdge[] = graphData.edges
+      .map((e) => {
+        const s = byId.get(e.source);
+        const t = byId.get(e.target);
+        if (!s || !t) return null;
+        const { source, target } = computeEdgeEndpoints(
+          s.x,
+          s.y,
+          s.width / 2,
+          s.height / 2,
+          t.x,
+          t.y,
+          t.width / 2,
+          t.height / 2
+        );
+        return {
+          id: e.id,
+          sourceId: e.source,
+          targetId: e.target,
+          source,
+          target,
+        } as DrawEdge;
+      })
+      .filter((e): e is DrawEdge => !!e);
+    setEdges(nextEdges);
+  }, [graphData?.edges, nodes]);
+
+  const getPoint = (e: React.MouseEvent | MouseEvent) => {
+    if (!svgRef.current) return { x: 0, y: 0 };
+    const ctm = svgRef.current.getScreenCTM();
+    if (!ctm) return { x: 0, y: 0 };
+    const clientX = 'clientX' in e ? e.clientX : 0;
+    const clientY = 'clientY' in e ? e.clientY : 0;
+    return {
+      x: (clientX - ctm.e) / ctm.a,
+      y: (clientY - ctm.f) / ctm.d,
+    };
+  };
+
+  const handleMouseDown = (e: React.MouseEvent, nodeId: string) => {
+    e.preventDefault();
+    movedRef.current = false;
+    const node = nodes.find((n) => n.id === nodeId);
+    if (!node) return;
+    const pt = getPoint(e);
+    setDragging({
+      nodeId,
+      offsetX: pt.x - node.x,
+      offsetY: pt.y - node.y,
+      startX: node.x,
+      startY: node.y,
+    });
+  };
+
+  // Drag interactions on the SVG (for performance we also attach to window)
+  const handleSvgMouseMove = (e: React.MouseEvent) => {
+    if (!dragging) return;
+    e.preventDefault();
+    const pt = getPoint(e);
+    const newX = pt.x - dragging.offsetX;
+    const newY = pt.y - dragging.offsetY;
+    const dist = Math.hypot(newX - dragging.startX, newY - dragging.startY);
+    movedRef.current = dist > 3;
+
+    setNodes((prev) =>
+      prev.map((n) => (n.id === dragging.nodeId ? { ...n, x: newX, y: newY } : n))
+    );
+    setEdges((prev) =>
+      prev.map((edge) => {
+        if (edge.sourceId === dragging.nodeId) {
+          const targetNode = nodes.find((n) => n.id === edge.targetId);
+          if (!targetNode) return edge;
+          const { source, target } = computeEdgeEndpoints(
+            newX,
+            newY,
+            (nodes.find(n => n.id === dragging.nodeId)?.width || NODE_DIM.width) / 2,
+            (nodes.find(n => n.id === dragging.nodeId)?.height || NODE_DIM.height) / 2,
+            targetNode.x,
+            targetNode.y,
+            targetNode.width / 2,
+            targetNode.height / 2
+          );
+          return { ...edge, source, target };
+        }
+        if (edge.targetId === dragging.nodeId) {
+          const sourceNode = nodes.find((n) => n.id === edge.sourceId);
+          if (!sourceNode) return edge;
+          const { source, target } = computeEdgeEndpoints(
+            sourceNode.x,
+            sourceNode.y,
+            sourceNode.width / 2,
+            sourceNode.height / 2,
+            newX,
+            newY,
+            (nodes.find(n => n.id === dragging.nodeId)?.width || NODE_DIM.width) / 2,
+            (nodes.find(n => n.id === dragging.nodeId)?.height || NODE_DIM.height) / 2
+          );
+          return { ...edge, source, target };
+        }
+        return edge;
+      })
+    );
+  };
 
-  const { nodes, edges } = useMemo(() => {
-    const mappedNodes: Node[] = graphData.nodes.map((node) => ({
-      id: node.id,
-      data: { label: node.label },
-      position: { x: 0, y: 0 },
-      ...nodeDefaults,
-    }));
+  const handleSvgMouseUp = (e: React.MouseEvent) => {
+    if (dragging) e.preventDefault();
+    setDragging(null);
+  };
 
-    const mappedEdges: Edge[] = graphData.edges.map((edge) => ({
-      id: edge.id,
-      source: edge.source,
-      target: edge.target,
-      animated: true,
-    }));
+  useEffect(() => {
+    const onMove = (e: MouseEvent) => {
+      if (!dragging) return;
+      const pt = getPoint(e);
+      const newX = pt.x - dragging.offsetX;
+      const newY = pt.y - dragging.offsetY;
+      const dist = Math.hypot(newX - dragging.startX, newY - dragging.startY);
+      movedRef.current = dist > 3;
+      setNodes((prev) =>
+        prev.map((n) => (n.id === dragging.nodeId ? { ...n, x: newX, y: newY } : n))
+      );
+      setEdges((prev) =>
+        prev.map((edge) => {
+          if (edge.sourceId === dragging.nodeId) {
+            const targetNode = nodes.find((n) => n.id === edge.targetId);
+            if (!targetNode) return edge;
+            const { source, target } = computeEdgeEndpoints(
+              newX,
+              newY,
+              (nodes.find(n => n.id === dragging.nodeId)?.width || NODE_DIM.width) / 2,
+              (nodes.find(n => n.id === dragging.nodeId)?.height || NODE_DIM.height) / 2,
+              targetNode.x,
+              targetNode.y,
+              targetNode.width / 2,
+              targetNode.height / 2
+            );
+            return { ...edge, source, target };
+          }
+          if (edge.targetId === dragging.nodeId) {
+            const sourceNode = nodes.find((n) => n.id === edge.sourceId);
+            if (!sourceNode) return edge;
+            const { source, target } = computeEdgeEndpoints(
+              sourceNode.x,
+              sourceNode.y,
+              sourceNode.width / 2,
+              sourceNode.height / 2,
+              newX,
+              newY,
+              (nodes.find(n => n.id === dragging.nodeId)?.width || NODE_DIM.width) / 2,
+              (nodes.find(n => n.id === dragging.nodeId)?.height || NODE_DIM.height) / 2
+            );
+            return { ...edge, source, target };
+          }
+          return edge;
+        })
+      );
+    };
 
-    return { nodes: mappedNodes, edges: mappedEdges };
-  }, [graphData]);
+    const onUp = () => setDragging(null);
+
+    window.addEventListener('mousemove', onMove);
+    window.addEventListener('mouseup', onUp);
+    return () => {
+      window.removeEventListener('mousemove', onMove);
+      window.removeEventListener('mouseup', onUp);
+    };
+  }, [dragging]);
+
+  const headerColor = useMemo(() => 'hsl(var(--primary))', []);
+  const mutedStroke = useMemo(() => 'hsl(var(--muted-foreground))', []);
+  const activeStroke = useMemo(() => 'hsl(var(--primary))', []);
+  const dangerStroke = useMemo(() => 'hsl(var(--destructive))', []);
+
+  const isNodeActive = (id: string) => hoveredNode === id;
+
+  if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+    return (
+      <div className="flex items-center justify-center h-[600px] text-muted-foreground">
+        <p>No graph data available.</p>
+      </div>
+    );
+  }
 
   return (
     <Card className="w-full h-[600px] p-0 overflow-hidden relative">
-      <ReactFlowProvider>
-        <DagreLayout nodes={nodes} edges={edges}>
-          {(layoutedNodes, layoutedEdges) => (
-            <ReactFlow
-              nodes={layoutedNodes}
-              edges={layoutedEdges}
-              fitView
-              className="bg-background"
-              proOptions={{ hideAttribution: true }}
+      <TooltipProvider>
+        <svg
+          ref={svgRef}
+          width="100%"
+          height={SVG_HEIGHT}
+          viewBox={`0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`}
+          className="rounded-lg border bg-muted/10"
+          style={{ cursor: dragging ? 'grabbing' as const : 'default' }}
+          onMouseMove={handleSvgMouseMove}
+          onMouseUp={handleSvgMouseUp}
+        >
+          <defs>
+            <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
+              <feDropShadow
+                dx="2"
+                dy="2"
+                stdDeviation="3"
+                floodColor="hsl(var(--foreground))"
+                floodOpacity="0.08"
+              />
+            </filter>
+            <marker
+              id="arrowhead"
+              viewBox="0 0 10 10"
+              refX="10"
+              refY="5"
+              markerUnits="userSpaceOnUse"
+              markerWidth="12"
+              markerHeight="12"
+              orient="auto-start-reverse"
+            >
+              <path d="M 0 0 L 10 5 L 0 10 z" fill={mutedStroke} opacity="0.8" />
+            </marker>
+            <marker
+              id="arrowhead-active"
+              viewBox="0 0 10 10"
+              refX="10"
+              refY="5"
+              markerUnits="userSpaceOnUse"
+              markerWidth="12"
+              markerHeight="12"
+              orient="auto-start-reverse"
             >
-              <Controls />
-              <MiniMap />
-              <Background gap={12} size={1} />
-            </ReactFlow>
-          )}
-        </DagreLayout>
-      </ReactFlowProvider>
+              <path d="M 0 0 L 10 5 L 0 10 z" fill={activeStroke} />
+            </marker>
+          </defs>
+
+          {/* Edges */}
+          <g>
+            {edges.map((edge) => {
+              const isActive =
+                hoveredNode === edge.sourceId || hoveredNode === edge.targetId;
+              return (
+                <line
+                  key={edge.id}
+                  x1={edge.source.x}
+                  y1={edge.source.y}
+                  x2={edge.target.x}
+                  y2={edge.target.y}
+                  stroke={isActive ? activeStroke : mutedStroke}
+                  strokeWidth={isActive ? 2 : 1.5}
+                  strokeOpacity={isActive ? 1 : 0.6}
+                  markerEnd={isActive ? 'url(#arrowhead-active)' : 'url(#arrowhead)'}
+                  className="transition-[stroke,stroke-width,stroke-opacity] duration-200"
+                />
+              );
+            })}
+          </g>
+
+          {/* Nodes */}
+          <g>
+            {nodes.map((node, idx) => {
+              const isHovered = isNodeActive(node.id);
+              const isDragging = dragging?.nodeId === node.id;
+              const translateX = node.x - node.width / 2;
+              const translateY = node.y - node.height / 2;
+              const stepNumber = (() => {
+                const m = node.id.match(/\d+/);
+                return m ? parseInt(m[0], 10) : idx + 1;
+              })();
+
+              return (
+                <Tooltip key={node.id} delayDuration={100}>
+                  <TooltipTrigger asChild>
+                    <g
+                      transform={`translate(${translateX}, ${translateY})`}
+                      onMouseEnter={() => setHoveredNode(node.id)}
+                      onMouseLeave={() => setHoveredNode(null)}
+                      onMouseDown={(e) => handleMouseDown(e, node.id)}
+                      onClick={(e) => {
+                        e.stopPropagation();
+                        if (!movedRef.current) {
+                          setSelectedNode(node);
+                          setOpen(true);
+                        }
+                      }}
+                      style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
+                    >
+                      <g
+                        style={{
+                          transform: isHovered || isDragging ? 'scale(1.05)' : 'scale(1)',
+                          transition: 'transform 0.15s ease-out',
+                          transformOrigin: 'center center',
+                        }}
+                        filter="url(#shadow)"
+                      >
+                        <rect
+                          width={node.width}
+                          height={node.height}
+                          rx={NODE_DIM.rx}
+                          fill="hsl(var(--card))"
+                          stroke={isHovered || isDragging ? activeStroke : 'hsl(var(--border))'}
+                          strokeWidth={isHovered || isDragging ? 2 : 1}
+                        />
+                        <rect
+                          width={node.width}
+                          height={HEADER_H}
+                          fill={headerColor}
+                          opacity="0.15"
+                          style={{
+                            borderTopLeftRadius: NODE_DIM.rx,
+                            borderTopRightRadius: NODE_DIM.rx,
+                          }}
+                        />
+                        <line
+                          x1="0"
+                          y1={HEADER_H}
+                          x2={node.width}
+                          y2={HEADER_H}
+                          stroke={headerColor}
+                          strokeOpacity="0.35"
+                        />
+
+                        {/* Header text (small) */}
+                        <text
+                          x={12}
+                          y={HEADER_H - 8}
+                          fill={headerColor}
+                          style={{ fontSize: 10, fontWeight: 700, letterSpacing: '0.08em' }}
+                        >
+                          {`Step ${stepNumber}`}
+                        </text>
+
+                        {/* Label (wrapped to lines) */}
+                        <text
+                          x={12}
+                          y={HEADER_H + TITLE_PADDING_Y + 4}
+                          fill="hsl(var(--foreground))"
+                          style={{ fontSize: 14, fontWeight: 600, fontFamily: 'ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto' }}
+                        >
+                          {node.lines.map((ln, i) => (
+                            <tspan key={i} x={12} dy={i === 0 ? 0 : TITLE_LINE_HEIGHT}>
+                              {ln}
+                            </tspan>
+                          ))}
+                        </text>
+                      </g>
+                    </g>
+                  </TooltipTrigger>
+                  <TooltipContent>
+                    <p className="max-w-xs font-sans font-semibold">{node.label}</p>
+                    <p className="max-w-xs text-muted-foreground text-xs">ID: {node.id}</p>
+                  </TooltipContent>
+                </Tooltip>
+              );
+            })}
+          </g>
+        </svg>
+        <Dialog open={open} onOpenChange={setOpen}>
+          <DialogContent className="sm:max-w-2xl">
+            <DialogHeader>
+              <DialogTitle>{selectedNode?.label}</DialogTitle>
+            </DialogHeader>
+            <div className="max-h-[60vh] overflow-auto">
+              {selectedNode?.content ? (
+                <KatexRenderer content={selectedNode.content} />
+              ) : (
+                <p className="text-sm text-muted-foreground">No content for this step.</p>
+              )}
+            </div>
+          </DialogContent>
+        </Dialog>
+      </TooltipProvider>
     </Card>
   );
 }
